{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EDAC Testing and Education Platform This is basically a testing and educatiing platform so that you can - Learn Basic Error Detecting And Correcting - Use the EDAC code - Test your EDAC","title":"EDAC Testing and Education Platform"},{"location":"#edac-testing-and-education-platform","text":"This is basically a testing and educatiing platform so that you can - Learn Basic Error Detecting And Correcting - Use the EDAC code - Test your EDAC","title":"EDAC Testing and Education Platform"},{"location":"sources/","text":"EDAC A Learning Program for Error Decoding and Correction Installations git clone https://github.com/N0Ball/EDAC.git python3 -m pip install -r requirements Docs Documentations make view-docs # Open a server to view documentation make build-docs # Auto create docs from code make deploy-docs # Create doc on github page","title":"EDAC"},{"location":"sources/#edac","text":"A Learning Program for Error Decoding and Correction","title":"EDAC"},{"location":"sources/#installations","text":"git clone https://github.com/N0Ball/EDAC.git python3 -m pip install -r requirements","title":"Installations"},{"location":"sources/#docs","text":"Documentations make view-docs # Open a server to view documentation make build-docs # Auto create docs from code make deploy-docs # Create doc on github page","title":"Docs"},{"location":"sources/modules/edac/factory/","text":"EDACFactory source EDACFactory( edac_type: EDACType, debug: bool = False ) Creates the EDAC System specify by given EDAC Type Args edac_type ( EDACType ) : The EDAC type needed debug (bool) : Debug Level Methods: .decode source .decode( data: bytes, n: int = None ) Decodes the data to verify the integrity Args data (bytes) : The data to be decode Returns tuple (bool, bytes, list) : should be formated (error, original data, error bits) .encode source .encode( data: bytes, n: int = None ) Encodes the data with edac system Args data (bytes) : The data to be encoded n (int) : The block size given ( None as default) Returns bytes : The data encoded ._create_block source ._create_block( data: bytes, n: int ) Parse data into blocks so that every block have n bits of data Raises ValueError : If the data's type isn't bytes Returns list : the list of blocks needed .__get_edac_generator source .__get_edac_generator( edac_type: EDACType ) Get the edac system specified by EDACType Raises ValueError : If no EDAC Type was found Returns EDAC system","title":"Factory"},{"location":"sources/modules/edac/factory/#_1","text":"","title":""},{"location":"sources/modules/edac/factory/#edacfactory","text":"source EDACFactory( edac_type: EDACType, debug: bool = False ) Creates the EDAC System specify by given EDAC Type Args edac_type ( EDACType ) : The EDAC type needed debug (bool) : Debug Level Methods:","title":"EDACFactory"},{"location":"sources/modules/edac/factory/#decode","text":"source .decode( data: bytes, n: int = None ) Decodes the data to verify the integrity Args data (bytes) : The data to be decode Returns tuple (bool, bytes, list) : should be formated (error, original data, error bits)","title":".decode"},{"location":"sources/modules/edac/factory/#encode","text":"source .encode( data: bytes, n: int = None ) Encodes the data with edac system Args data (bytes) : The data to be encoded n (int) : The block size given ( None as default) Returns bytes : The data encoded","title":".encode"},{"location":"sources/modules/edac/factory/#_create_block","text":"source ._create_block( data: bytes, n: int ) Parse data into blocks so that every block have n bits of data Raises ValueError : If the data's type isn't bytes Returns list : the list of blocks needed","title":"._create_block"},{"location":"sources/modules/edac/factory/#__get_edac_generator","text":"source .__get_edac_generator( edac_type: EDACType ) Get the edac system specified by EDACType Raises ValueError : If no EDAC Type was found Returns EDAC system","title":".__get_edac_generator"},{"location":"sources/modules/edac/scheme/","text":"EDACType source EDACType() Enumerate of the EDAC Type system EDACMethod source EDACMethod( edac_type: EDACType = EDACType.NO_EDAC, debug: bool = False ) The Base class of the EDAC Method which means that all EDAC should contains all the methods it contains and will only be call the method it contains Args TYPE ( EDACType ) : The type of the EDAC system DEBUG (bool) : Debug flag Methods: .decode source .decode( data: int, check: int ) The method that the EDAC system need to decode for checking the correctness Args data (int) : The data to be checked check (int) : Parity Code to check Returns tuple : format should be (error, data, error bits) error (bool) : Is the data corrupted data (bytes) : The fixed data (return 0x00 if can't be fixed) bits (list) : The index of errorbits .get_default_block source .get_default_block() Generate default block of the EDAC system Returns int : default block of the EDAC system .encode source .encode( data: int ) The method that the EDAC system need to encode for futher EDAC usage Args data (int) : the data to be encoded Returns int : the data encoded .get_parity_size source .get_parity_size() Generate the parity size of the EDAC system Returns int : parity size of the EDAC system","title":"Scheme"},{"location":"sources/modules/edac/scheme/#_1","text":"","title":""},{"location":"sources/modules/edac/scheme/#edactype","text":"source EDACType() Enumerate of the EDAC Type system","title":"EDACType"},{"location":"sources/modules/edac/scheme/#edacmethod","text":"source EDACMethod( edac_type: EDACType = EDACType.NO_EDAC, debug: bool = False ) The Base class of the EDAC Method which means that all EDAC should contains all the methods it contains and will only be call the method it contains Args TYPE ( EDACType ) : The type of the EDAC system DEBUG (bool) : Debug flag Methods:","title":"EDACMethod"},{"location":"sources/modules/edac/scheme/#decode","text":"source .decode( data: int, check: int ) The method that the EDAC system need to decode for checking the correctness Args data (int) : The data to be checked check (int) : Parity Code to check Returns tuple : format should be (error, data, error bits) error (bool) : Is the data corrupted data (bytes) : The fixed data (return 0x00 if can't be fixed) bits (list) : The index of errorbits","title":".decode"},{"location":"sources/modules/edac/scheme/#get_default_block","text":"source .get_default_block() Generate default block of the EDAC system Returns int : default block of the EDAC system","title":".get_default_block"},{"location":"sources/modules/edac/scheme/#encode","text":"source .encode( data: int ) The method that the EDAC system need to encode for futher EDAC usage Args data (int) : the data to be encoded Returns int : the data encoded","title":".encode"},{"location":"sources/modules/edac/scheme/#get_parity_size","text":"source .get_parity_size() Generate the parity size of the EDAC system Returns int : parity size of the EDAC system","title":".get_parity_size"},{"location":"sources/modules/edac/methods/hammingcode/","text":"HammingCode source HammingCode( debug: bool = False ) EDAC System to deal with data that needs hamming code Args debug (bool, optional) : Debug level. Defaults to False. Methods: .decode source .decode( data: int, check: int ) Decode the given data Args data (int) : the given data check (int) : parity bytes Returns tuple : the results of the decode see more ._create_table source ._create_table( data: int ) Create the hamming table according to the given block size Args data (int) : data Returns list : hamming table .encode source .encode( data: int ) Encode the given data Args data (int) : the data in integer Returns int : the encoded data in integer","title":"Hammingcode"},{"location":"sources/modules/edac/methods/hammingcode/#_1","text":"","title":""},{"location":"sources/modules/edac/methods/hammingcode/#hammingcode","text":"source HammingCode( debug: bool = False ) EDAC System to deal with data that needs hamming code Args debug (bool, optional) : Debug level. Defaults to False. Methods:","title":"HammingCode"},{"location":"sources/modules/edac/methods/hammingcode/#decode","text":"source .decode( data: int, check: int ) Decode the given data Args data (int) : the given data check (int) : parity bytes Returns tuple : the results of the decode see more","title":".decode"},{"location":"sources/modules/edac/methods/hammingcode/#_create_table","text":"source ._create_table( data: int ) Create the hamming table according to the given block size Args data (int) : data Returns list : hamming table","title":"._create_table"},{"location":"sources/modules/edac/methods/hammingcode/#encode","text":"source .encode( data: int ) Encode the given data Args data (int) : the data in integer Returns int : the encoded data in integer","title":".encode"},{"location":"sources/modules/edac/methods/parity/","text":"Parity source Parity( debug: bool = False ) A Parity EDAC System to deal with data that needs parity code added Args debug (bool, optional) : Debug Level. Defaults to False. Methods: .decode source .decode( data: int, check: int ) Check the if the data is same as the given parity code See Also EDACMethod Args data (int) : given data check (int) : parity bit Returns tuple : ( error , data , error bits ) error (bool) : If any error happens in the data data (int) : the corrected data ( 0 for CI ) bits (list) : the index of the error bits CI for Cannot Identify .encode source .encode( data: int ) encode the given integer (was bytes) Args data (int) : given integer Returns int : integer that is encoded","title":"Parity"},{"location":"sources/modules/edac/methods/parity/#_1","text":"","title":""},{"location":"sources/modules/edac/methods/parity/#parity","text":"source Parity( debug: bool = False ) A Parity EDAC System to deal with data that needs parity code added Args debug (bool, optional) : Debug Level. Defaults to False. Methods:","title":"Parity"},{"location":"sources/modules/edac/methods/parity/#decode","text":"source .decode( data: int, check: int ) Check the if the data is same as the given parity code See Also EDACMethod Args data (int) : given data check (int) : parity bit Returns tuple : ( error , data , error bits ) error (bool) : If any error happens in the data data (int) : the corrected data ( 0 for CI ) bits (list) : the index of the error bits CI for Cannot Identify","title":".decode"},{"location":"sources/modules/edac/methods/parity/#encode","text":"source .encode( data: int ) encode the given integer (was bytes) Args data (int) : given integer Returns int : integer that is encoded","title":".encode"},{"location":"sources/modules/noise/factory/","text":"NoiseFactory source NoiseFactory( noise_type: NoiseType, debug: bool = False, **kwargs ) Creates a noise system to add noise to. Args noise_type ( NoiseType ) : The noise type of the given type debug (bool, optional) : The debug flag. Defaults to False. Example >>> noise_system = NoiseFactory(NoiseType.NO_NOISE) >>> noise_system.add_noise(b\"123\") b'123' SeeAlso: NoiseType Methods: .add_noise source .add_noise( data: bytes ) Add noise to the data Args data (bytes) : data to add noise on Raises ValueError : data's type is not bytes Returns bytes : the data with the noise .__get_noise_generator source .__get_noise_generator( noise_type: NoiseType ) Get the noise system of the given noise type Args noise_type ( NoiseType ) : the givin noise type seealso: noise.shceme.NoiseType Raises ValueError : No noise type found Returns NoiseMethod : the noise system","title":"Factory"},{"location":"sources/modules/noise/factory/#_1","text":"","title":""},{"location":"sources/modules/noise/factory/#noisefactory","text":"source NoiseFactory( noise_type: NoiseType, debug: bool = False, **kwargs ) Creates a noise system to add noise to. Args noise_type ( NoiseType ) : The noise type of the given type debug (bool, optional) : The debug flag. Defaults to False. Example >>> noise_system = NoiseFactory(NoiseType.NO_NOISE) >>> noise_system.add_noise(b\"123\") b'123' SeeAlso: NoiseType Methods:","title":"NoiseFactory"},{"location":"sources/modules/noise/factory/#add_noise","text":"source .add_noise( data: bytes ) Add noise to the data Args data (bytes) : data to add noise on Raises ValueError : data's type is not bytes Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/factory/#__get_noise_generator","text":"source .__get_noise_generator( noise_type: NoiseType ) Get the noise system of the given noise type Args noise_type ( NoiseType ) : the givin noise type seealso: noise.shceme.NoiseType Raises ValueError : No noise type found Returns NoiseMethod : the noise system","title":".__get_noise_generator"},{"location":"sources/modules/noise/scheme/","text":"NoiseType source NoiseType() The Noise type Enumerate of the Noise system Attributes NO_NOISE (A system with no Noise) : see also NO_NOISE BIT_FLIP (A system that flip bits) : see also BIT_FLIP NoiseMethod source NoiseMethod( noise_type: NoiseType = NoiseType.NO_NOISE, debug: bool = False ) The Base class fo the Noise Method Args TYPE (NoiseType) : The type of noise system DEBUG (bool) : Debug Flag Note This is the abstract base class, add_noise method should never be called Methods: .add_noise source .add_noise( data: bytes ) Add the noise to the data from the noise system Args data (bytes) : the data that the noise is going to add on Returns bytes : the data with the noise","title":"Scheme"},{"location":"sources/modules/noise/scheme/#_1","text":"","title":""},{"location":"sources/modules/noise/scheme/#noisetype","text":"source NoiseType() The Noise type Enumerate of the Noise system Attributes NO_NOISE (A system with no Noise) : see also NO_NOISE BIT_FLIP (A system that flip bits) : see also BIT_FLIP","title":"NoiseType"},{"location":"sources/modules/noise/scheme/#noisemethod","text":"source NoiseMethod( noise_type: NoiseType = NoiseType.NO_NOISE, debug: bool = False ) The Base class fo the Noise Method Args TYPE (NoiseType) : The type of noise system DEBUG (bool) : Debug Flag Note This is the abstract base class, add_noise method should never be called Methods:","title":"NoiseMethod"},{"location":"sources/modules/noise/scheme/#add_noise","text":"source .add_noise( data: bytes ) Add the noise to the data from the noise system Args data (bytes) : the data that the noise is going to add on Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/systems/BIT_FLIP/","text":"BitFlipNoise source BitFlipNoise( debug: bool, kwargs: dict = None ) Add the Bit Flip Noise System to the data Args debug (bool) : the debug flag kwargs (optional) : The key word argument passed from Noise Factory . Defaults to None. should contain key flip_list flip_list (list[int]) : A list of integer index that defines the bit index that should be flipped Note the **kwargs should be flip_list (list[int]) , if no such key in **kwargs it will auto flips a random bit Example >>> from lib.noise.scheme import NoiseType >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP, flip_list=[6]) >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP) >>> noise_system.add_noise(b'OUO') b'OuO' >>> noise_system.add_noise(b'OUO') b'O\u00d5O' Methods: .__add_noise source .__add_noise( data: bytes ) The method to add noise Args data (bytes) : The data to add noise at Returns bytes : the data with the noise Note The algorithm of this method is using a xor mask to flip the data , since x ^ 0 = x, x ^ 1 = !x Given an example | 0 | 1 | 2 | 3 | 4 | | 1 | 0 | 1 | 1 | 0 | --------------------- XOR | 0 | 0 | 1 | 0 | 1 | --------------------- Results | 1 | 0 |*0*| 1 |*1*| You can see that except the 2^{nd} and the 4^{th} data, the data remains the same. .add_noise source .add_noise( data: bytes ) Validate the flip_list and add the noise to the data Args data (bytes) : The data to be noise added Raises IndexError : the flip_list contains integers that exceeds the length of the original data Returns bytes : the data with the noise","title":"BIT FLIP"},{"location":"sources/modules/noise/systems/BIT_FLIP/#_1","text":"","title":""},{"location":"sources/modules/noise/systems/BIT_FLIP/#bitflipnoise","text":"source BitFlipNoise( debug: bool, kwargs: dict = None ) Add the Bit Flip Noise System to the data Args debug (bool) : the debug flag kwargs (optional) : The key word argument passed from Noise Factory . Defaults to None. should contain key flip_list flip_list (list[int]) : A list of integer index that defines the bit index that should be flipped Note the **kwargs should be flip_list (list[int]) , if no such key in **kwargs it will auto flips a random bit Example >>> from lib.noise.scheme import NoiseType >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP, flip_list=[6]) >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP) >>> noise_system.add_noise(b'OUO') b'OuO' >>> noise_system.add_noise(b'OUO') b'O\u00d5O' Methods:","title":"BitFlipNoise"},{"location":"sources/modules/noise/systems/BIT_FLIP/#__add_noise","text":"source .__add_noise( data: bytes ) The method to add noise Args data (bytes) : The data to add noise at Returns bytes : the data with the noise Note The algorithm of this method is using a xor mask to flip the data , since x ^ 0 = x, x ^ 1 = !x Given an example | 0 | 1 | 2 | 3 | 4 | | 1 | 0 | 1 | 1 | 0 | --------------------- XOR | 0 | 0 | 1 | 0 | 1 | --------------------- Results | 1 | 0 |*0*| 1 |*1*| You can see that except the 2^{nd} and the 4^{th} data, the data remains the same.","title":".__add_noise"},{"location":"sources/modules/noise/systems/BIT_FLIP/#add_noise","text":"source .add_noise( data: bytes ) Validate the flip_list and add the noise to the data Args data (bytes) : The data to be noise added Raises IndexError : the flip_list contains integers that exceeds the length of the original data Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/systems/NO_NOISE/","text":"NoNoise source NoNoise( debug: bool ) A Noise system without any noise Args debug (bool) : the debug flag Methods: .add_noise source .add_noise( data: bytes ) The Method of adding noise to the data Args data (bytes) : the data that is going to add noise on Returns bytes : the data with noise","title":"NO NOISE"},{"location":"sources/modules/noise/systems/NO_NOISE/#_1","text":"","title":""},{"location":"sources/modules/noise/systems/NO_NOISE/#nonoise","text":"source NoNoise( debug: bool ) A Noise system without any noise Args debug (bool) : the debug flag Methods:","title":"NoNoise"},{"location":"sources/modules/noise/systems/NO_NOISE/#add_noise","text":"source .add_noise( data: bytes ) The Method of adding noise to the data Args data (bytes) : the data that is going to add noise on Returns bytes : the data with noise","title":".add_noise"},{"location":"tutorials/ErrorDetection/hammingCode/","text":"Hamming Code A SEC-DED Method that can detect and correct errors. How The index of the data can be seperate into different groups due to the index of it's binary data. [1] Therefore, the index of a 2^n -bits data can be presented with n-bits. If we set the significant bit [2] as the parity bit of each group, we can know which groups contains error. If there are only one error bit, the combination of the groups that contains error is the index of the bit that is error. [4] The 0^{th} bit of the data doesn't belongs to any group, so that we can't use the above method to identify if it is correct or not. However we can set the 0^{th} bit as the parity bit to the whole data string. Since groups expect that there are only one errors in the data; however if there exists over one errors, the groups will only try to fix one error (which is also the wrong one). So we set the 0^{th} bit of the data as a parity bit so that if there are two errors is the system, the groups can fix (however fix the wrong bit) the data, so that the 0^{th} bit parity can be detected the correctness of the data. For every 2^n -bit data, we need n-bit parity bits The combinations of the error groups can identify the error ( for SEC ) The 0^{th} -bit is the parity bit of the total data ( for DED ) Examples take 2^3 bit, which is (8-3-1, 4) -> (4, 4) hamming code as an example Encode If the data is '1011' -> the message will be xxx1x011 GROUPS 0: x, 1, 0, 1 -> x = 0 1: x, 1, 1, 1 -> x = 1 2: x, 0, 1, 1 -> x = 0 Therefore the message is x0110011 -> x = 0 We get the final message 00110011 Decode Simply get rid of the parity bits: 00110011 -> xxx1x011 -> 1011 Error Detection 00110011 -> 00110111 (change bit 5) GROUPS 0: 0, 1, 1, 1 -> 1 -> INCORRECT 1: 1, 1, 1, 1 -> 0 -> CORRECT 2: 0, 1, 1, 1 -> 1 -> INCORRECT detect error -> 0b101 = 5 correct! 00110011 -> 00110001 (change bit 6) GROUPS 0: 0, 1, 0, 1 -> 0 -> CORRECT 1: 1, 1, 0, 1 -> 1 -> INCORRECT 2: 0, 0, 0, 1 -> 1 -> INCORRECT detect error -> 0b110 = 6 correct! More The result of this can be viewed as sum the index of the data that have 1 In this case: 2, 3, 6, 7 010 011 110 111 + --- 000 -> This is what we set, every group's sum is 0 Therefore, if 00110011 -> 00110111 (change bit 5) 010 011 101 110 111 + --- 101 = 5 -> This is the same as what we do above but turned 90 degrees That is, we can simply xor all the index that have 1 in the message, the result is the error. Reference [1] For example: 0 -> 0b000 1 -> 0b001 2 -> 0b010 3 -> 0b011 4 -> 0b100 5 -> 0b101 6 -> 0b110 7 -> 0b111 The 0^{th} group is 0, 2, 4, 7 , since the 0^{th} index of thier binaries are 1 ( 0b001 , 0b011 , 0b101 , 0b111 ). The 1^{st} group is 2, 3, 6, 7 ( 0b010 , 0b011 , 0b110 , 0b111 ). [2] The significant bit of a group is the bit that have only one 1 while presented in binary [3] . The reason we choose this is beacuse significsant bits are one and only to thier groups since they have only one 1 . That is, for group 0, 1 is the significant bit, and 1 is only in group 0; however 3 is not is because group 0 containes 3 , but 3 is in both group 0 and gorup 1. [3] For example: significant bit of the group 0 is 1 since 1 is 0b00000001 , which only one 1 exists in the binary, the significant bit of group 5 is 32, since 32 is 0b00100000 , also only one 1 is in it's binary. We can also say that the significant bit of group n is 2^n , since that is how binary is. [4] Take a 2^3 -bit data as an example: There are 3 groups O is Correct X is Incorrect Only single error occurs GROUPS: 0: 1, 3, 5, 7 1: 2, 3, 6, 7 2: 4, 5, 6, 7 COMBINATION RESULTS: | 2 | 1 | 0 | error bit | |---+---+---+-----------| | O | O | O | X | |---+---+---+-----------| | O | O | X | 1 | |---+---+---+-----------| | O | X | O | 2 | |---+---+---+-----------| | O | X | X | 3 | |---+---+---+-----------| | X | O | O | 4 | |---+---+---+-----------| | X | O | X | 5 | |---+---+---+-----------| | X | X | O | 6 | |---+---+---+-----------| | X | X | X | 7 | |-----------------------| If only group 1 is incorrect -> Second bit have error group 0, 2 is correct only 2 is in group 1 and not in 0, 2 If both group 0 and group 1 is incorrect -> Third bit have error. group 2 is correct only 3 is in group 0 and 1 but not in 2 If both group 1 and group 2 is incorrect -> Sixth bit have error. group 0 is correct only 5 is in group 1 and 2 but not in 0 Do you see the relation of error groups and indexs? If we see the incorrect groups as 1, the correct groups as 0, we can view the combination of groups as one binary number, the error is the result of the binary. If only group 1 is incorrect (0, 1, 0) -> 0b010 -> 2 the same results as above If both group 0 and group 1 is incorrect (0, 1, 1) -> 0b011 -> 3 the same reulsts as above If both group 1 and group 2 is incorrect (1, 1, 0) -> 0b110 -> 5 the same results as above","title":"hammingCode"},{"location":"tutorials/ErrorDetection/hammingCode/#_1","text":"","title":""},{"location":"tutorials/ErrorDetection/hammingCode/#hamming-code","text":"A SEC-DED Method that can detect and correct errors.","title":"Hamming Code"},{"location":"tutorials/ErrorDetection/hammingCode/#how","text":"The index of the data can be seperate into different groups due to the index of it's binary data. [1] Therefore, the index of a 2^n -bits data can be presented with n-bits. If we set the significant bit [2] as the parity bit of each group, we can know which groups contains error. If there are only one error bit, the combination of the groups that contains error is the index of the bit that is error. [4] The 0^{th} bit of the data doesn't belongs to any group, so that we can't use the above method to identify if it is correct or not. However we can set the 0^{th} bit as the parity bit to the whole data string. Since groups expect that there are only one errors in the data; however if there exists over one errors, the groups will only try to fix one error (which is also the wrong one). So we set the 0^{th} bit of the data as a parity bit so that if there are two errors is the system, the groups can fix (however fix the wrong bit) the data, so that the 0^{th} bit parity can be detected the correctness of the data. For every 2^n -bit data, we need n-bit parity bits The combinations of the error groups can identify the error ( for SEC ) The 0^{th} -bit is the parity bit of the total data ( for DED )","title":"How"},{"location":"tutorials/ErrorDetection/hammingCode/#examples","text":"take 2^3 bit, which is (8-3-1, 4) -> (4, 4) hamming code as an example","title":"Examples"},{"location":"tutorials/ErrorDetection/hammingCode/#encode","text":"If the data is '1011' -> the message will be xxx1x011 GROUPS 0: x, 1, 0, 1 -> x = 0 1: x, 1, 1, 1 -> x = 1 2: x, 0, 1, 1 -> x = 0 Therefore the message is x0110011 -> x = 0 We get the final message 00110011","title":"Encode"},{"location":"tutorials/ErrorDetection/hammingCode/#decode","text":"Simply get rid of the parity bits: 00110011 -> xxx1x011 -> 1011","title":"Decode"},{"location":"tutorials/ErrorDetection/hammingCode/#error-detection","text":"00110011 -> 00110111 (change bit 5) GROUPS 0: 0, 1, 1, 1 -> 1 -> INCORRECT 1: 1, 1, 1, 1 -> 0 -> CORRECT 2: 0, 1, 1, 1 -> 1 -> INCORRECT","title":"Error Detection"},{"location":"tutorials/ErrorDetection/hammingCode/#detect-error-0b101-5-correct","text":"00110011 -> 00110001 (change bit 6) GROUPS 0: 0, 1, 0, 1 -> 0 -> CORRECT 1: 1, 1, 0, 1 -> 1 -> INCORRECT 2: 0, 0, 0, 1 -> 1 -> INCORRECT detect error -> 0b110 = 6 correct!","title":"detect error -&gt; 0b101 = 5 correct!"},{"location":"tutorials/ErrorDetection/hammingCode/#more","text":"The result of this can be viewed as sum the index of the data that have 1 In this case: 2, 3, 6, 7 010 011 110 111 + --- 000 -> This is what we set, every group's sum is 0 Therefore, if 00110011 -> 00110111 (change bit 5) 010 011 101 110 111 + --- 101 = 5 -> This is the same as what we do above but turned 90 degrees That is, we can simply xor all the index that have 1 in the message, the result is the error.","title":"More"},{"location":"tutorials/ErrorDetection/hammingCode/#reference","text":"","title":"Reference"},{"location":"tutorials/ErrorDetection/hammingCode/#1","text":"For example: 0 -> 0b000 1 -> 0b001 2 -> 0b010 3 -> 0b011 4 -> 0b100 5 -> 0b101 6 -> 0b110 7 -> 0b111 The 0^{th} group is 0, 2, 4, 7 , since the 0^{th} index of thier binaries are 1 ( 0b001 , 0b011 , 0b101 , 0b111 ). The 1^{st} group is 2, 3, 6, 7 ( 0b010 , 0b011 , 0b110 , 0b111 ).","title":"[1]"},{"location":"tutorials/ErrorDetection/hammingCode/#2","text":"The significant bit of a group is the bit that have only one 1 while presented in binary [3] . The reason we choose this is beacuse significsant bits are one and only to thier groups since they have only one 1 . That is, for group 0, 1 is the significant bit, and 1 is only in group 0; however 3 is not is because group 0 containes 3 , but 3 is in both group 0 and gorup 1.","title":"[2]"},{"location":"tutorials/ErrorDetection/hammingCode/#3","text":"For example: significant bit of the group 0 is 1 since 1 is 0b00000001 , which only one 1 exists in the binary, the significant bit of group 5 is 32, since 32 is 0b00100000 , also only one 1 is in it's binary. We can also say that the significant bit of group n is 2^n , since that is how binary is.","title":"[3]"},{"location":"tutorials/ErrorDetection/hammingCode/#4","text":"Take a 2^3 -bit data as an example: There are 3 groups O is Correct X is Incorrect Only single error occurs GROUPS: 0: 1, 3, 5, 7 1: 2, 3, 6, 7 2: 4, 5, 6, 7 COMBINATION RESULTS: | 2 | 1 | 0 | error bit | |---+---+---+-----------| | O | O | O | X | |---+---+---+-----------| | O | O | X | 1 | |---+---+---+-----------| | O | X | O | 2 | |---+---+---+-----------| | O | X | X | 3 | |---+---+---+-----------| | X | O | O | 4 | |---+---+---+-----------| | X | O | X | 5 | |---+---+---+-----------| | X | X | O | 6 | |---+---+---+-----------| | X | X | X | 7 | |-----------------------| If only group 1 is incorrect -> Second bit have error group 0, 2 is correct only 2 is in group 1 and not in 0, 2 If both group 0 and group 1 is incorrect -> Third bit have error. group 2 is correct only 3 is in group 0 and 1 but not in 2 If both group 1 and group 2 is incorrect -> Sixth bit have error. group 0 is correct only 5 is in group 1 and 2 but not in 0 Do you see the relation of error groups and indexs? If we see the incorrect groups as 1, the correct groups as 0, we can view the combination of groups as one binary number, the error is the result of the binary. If only group 1 is incorrect (0, 1, 0) -> 0b010 -> 2 the same results as above If both group 0 and group 1 is incorrect (0, 1, 1) -> 0b011 -> 3 the same reulsts as above If both group 1 and group 2 is incorrect (1, 1, 0) -> 0b110 -> 5 the same results as above","title":"[4]"},{"location":"tutorials/ErrorDetection/parity/","text":"Parity bit Check Bit , which is a bit that can detect errors. How Examing the Least significant bit of the whole communication string Applied in an 8-bit communication system 7 + 1(parity) The parity bit is to set the sum of every bit to 0. If the sum of every bits isn't 0, which is not the original set: 0, we know that there is an error. Examples take 25 (0b11001) as an example 0 1 2 3 4 5 6 7 0 0 1 1 0 0 1 1 The parity bit is the 7 th bit, since the sum of every bit in 25 (0b11001) is 1 ; therefore the value of parity bit is 0 - 1 = 0 \\oplus 1 = 1 take 30 (0b11110) as an example 0 1 2 3 4 5 6 7 0 0 1 1 1 1 0 0 The parity bit is the 7 th bit, since the sum of every bit in 30 (0b11110) is 0 ; therefore the value of parity bit is 0 - 0 = 0 \\oplus 0 = 0 Error Detection If single bit flip occurs, the sum of the bits will not be 0. That is, you can simply sum every bits to check whether an error appears. a simple python code to check 30 (0b11110) is listed below >>> from functools import reduce >>> message = \"00111100\" # e = 0b0 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True >>> message = \"00110100\" # e = 0b1000 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 False Problems The bigest problem of parity bit is that you can't identify the error if the hamming distance H_d(m) \\gt 1 Check m = 30 (0b11110) again but with H_d(m) = 2 with error e 11000000 => m + e = (0b1111110) >>> from functools import reduce >>> message = \"11111100\" # Message recieved in Binary >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True The result is True which means no errors however, e \\ne 0 This is called a collision , which means two different system have the same parity code See also Numbers Summations Hamming Distance","title":"Parity"},{"location":"tutorials/ErrorDetection/parity/#_1","text":"","title":""},{"location":"tutorials/ErrorDetection/parity/#parity-bit","text":"Check Bit , which is a bit that can detect errors.","title":"Parity bit"},{"location":"tutorials/ErrorDetection/parity/#how","text":"Examing the Least significant bit of the whole communication string Applied in an 8-bit communication system 7 + 1(parity) The parity bit is to set the sum of every bit to 0. If the sum of every bits isn't 0, which is not the original set: 0, we know that there is an error.","title":"How"},{"location":"tutorials/ErrorDetection/parity/#examples","text":"take 25 (0b11001) as an example 0 1 2 3 4 5 6 7 0 0 1 1 0 0 1 1 The parity bit is the 7 th bit, since the sum of every bit in 25 (0b11001) is 1 ; therefore the value of parity bit is 0 - 1 = 0 \\oplus 1 = 1 take 30 (0b11110) as an example 0 1 2 3 4 5 6 7 0 0 1 1 1 1 0 0 The parity bit is the 7 th bit, since the sum of every bit in 30 (0b11110) is 0 ; therefore the value of parity bit is 0 - 0 = 0 \\oplus 0 = 0","title":"Examples"},{"location":"tutorials/ErrorDetection/parity/#error-detection","text":"If single bit flip occurs, the sum of the bits will not be 0. That is, you can simply sum every bits to check whether an error appears. a simple python code to check 30 (0b11110) is listed below >>> from functools import reduce >>> message = \"00111100\" # e = 0b0 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True >>> message = \"00110100\" # e = 0b1000 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 False","title":"Error Detection"},{"location":"tutorials/ErrorDetection/parity/#problems","text":"The bigest problem of parity bit is that you can't identify the error if the hamming distance H_d(m) \\gt 1 Check m = 30 (0b11110) again but with H_d(m) = 2 with error e 11000000 => m + e = (0b1111110) >>> from functools import reduce >>> message = \"11111100\" # Message recieved in Binary >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True The result is True which means no errors however, e \\ne 0 This is called a collision , which means two different system have the same parity code","title":"Problems"},{"location":"tutorials/ErrorDetection/parity/#see-also","text":"Numbers Summations Hamming Distance","title":"See also"},{"location":"tutorials/definitions/EDAC/","text":"Intro This is definitions of EDAC related page SEC-DED Singal Error Correction Double Error Detection Description EDAC schemes that are capable of detecting up to two simultaneous bit errors and correcting single-bit errors. Examples Hamming Codes Huffman Coding Hsiao SEC-DED","title":"EDAC"},{"location":"tutorials/definitions/EDAC/#_1","text":"","title":""},{"location":"tutorials/definitions/EDAC/#intro","text":"This is definitions of EDAC related page","title":"Intro"},{"location":"tutorials/definitions/EDAC/#sec-ded","text":"Singal Error Correction Double Error Detection","title":"SEC-DED"},{"location":"tutorials/definitions/EDAC/#description","text":"EDAC schemes that are capable of detecting up to two simultaneous bit errors and correcting single-bit errors.","title":"Description"},{"location":"tutorials/definitions/EDAC/#examples","text":"Hamming Codes Huffman Coding Hsiao SEC-DED","title":"Examples"},{"location":"tutorials/definitions/computerScience/","text":"Intro This is definitions of Computer Science related page Numbers The numbers in CS can be Binary \\rightarrow 0, 1 Octal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7 Decimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Hexadecimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, a, b, c, d, e, f Example take 25 as example >>> number = 25 >>> number #Decimal 25 >>> bin(number) #Binary '0b11001' >>> oct(number) #Octal '0o31' >>> hex(number) #Hexadecimal '0x19' The notation of this tutorial will always be: Binary -> 0b Octal -> 0o Decimal -> NA (No Notation) Hexadecimal -> 0x That is 0b11001 = 0o31 = 0x19 = 25 Least Significant Bit (LSB) the 1^{st} bit of the data, which is also the low-order bit or right-most bit Example >>> def LSB(n): ... return n&1 >>> number = 15 >>> bin(number) '0b1111' >>> LSB(number) 1 >>> number = 14 >>> bin(number) '0b1110' >>> LSB(number) 0 Most Significant Bit (MSB) The high-order bit or left-most bit Example Given a 8 bit system >>> def MSB(n): ... return n >> 7 ... >>> number = 215 >>> bin(number) '0b11010111' >>> MSB(number) 1 >>> number = 127 >>> bin(number) '0b1111111' #It's actuall 0b01111111 since it's a 8-bit system >>> MSB(number) 0","title":"computerScience"},{"location":"tutorials/definitions/computerScience/#_1","text":"","title":""},{"location":"tutorials/definitions/computerScience/#intro","text":"This is definitions of Computer Science related page","title":"Intro"},{"location":"tutorials/definitions/computerScience/#numbers","text":"The numbers in CS can be Binary \\rightarrow 0, 1 Octal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7 Decimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Hexadecimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, a, b, c, d, e, f","title":"Numbers"},{"location":"tutorials/definitions/computerScience/#example","text":"take 25 as example >>> number = 25 >>> number #Decimal 25 >>> bin(number) #Binary '0b11001' >>> oct(number) #Octal '0o31' >>> hex(number) #Hexadecimal '0x19' The notation of this tutorial will always be: Binary -> 0b Octal -> 0o Decimal -> NA (No Notation) Hexadecimal -> 0x That is 0b11001 = 0o31 = 0x19 = 25","title":"Example"},{"location":"tutorials/definitions/computerScience/#least-significant-bit-lsb","text":"the 1^{st} bit of the data, which is also the low-order bit or right-most bit","title":"Least Significant Bit (LSB)"},{"location":"tutorials/definitions/computerScience/#example_1","text":">>> def LSB(n): ... return n&1 >>> number = 15 >>> bin(number) '0b1111' >>> LSB(number) 1 >>> number = 14 >>> bin(number) '0b1110' >>> LSB(number) 0","title":"Example"},{"location":"tutorials/definitions/computerScience/#most-significant-bit-msb","text":"The high-order bit or left-most bit","title":"Most Significant Bit (MSB)"},{"location":"tutorials/definitions/computerScience/#example_2","text":"Given a 8 bit system >>> def MSB(n): ... return n >> 7 ... >>> number = 215 >>> bin(number) '0b11010111' >>> MSB(number) 1 >>> number = 127 >>> bin(number) '0b1111111' #It's actuall 0b01111111 since it's a 8-bit system >>> MSB(number) 0","title":"Example"},{"location":"tutorials/definitions/math/","text":"Intro This is definitions of mathematic related page Summations In Communication systems, the summation of bits or strings is in a Galios Field (GF) Example take GF(2) for example A B Operation Result 0 0 +/- 0 0 1 +/- 1 1 0 +/- 1 1 1 +/- 0 0 0 x 0 0 1 x 0 1 0 x 0 1 1 x 1 As you can see, the +/- in GF(2) is also xor operation and x is and operation. That is a \\pm b = a \\oplus b \\\\[1em] a \\times b = a \\& b Hamming Distance Hamming distance is the number of errors in a communication system. Example H_d(\\text{12345}, \\text{22345}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{12545}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{22355}) = 2 \\\\[1em] H_d(\\text{12345}, \\text{54321}) = 4 \\\\[1em]","title":"Math"},{"location":"tutorials/definitions/math/#_1","text":"","title":""},{"location":"tutorials/definitions/math/#intro","text":"This is definitions of mathematic related page","title":"Intro"},{"location":"tutorials/definitions/math/#summations","text":"In Communication systems, the summation of bits or strings is in a Galios Field (GF)","title":"Summations"},{"location":"tutorials/definitions/math/#example","text":"take GF(2) for example A B Operation Result 0 0 +/- 0 0 1 +/- 1 1 0 +/- 1 1 1 +/- 0 0 0 x 0 0 1 x 0 1 0 x 0 1 1 x 1 As you can see, the +/- in GF(2) is also xor operation and x is and operation. That is a \\pm b = a \\oplus b \\\\[1em] a \\times b = a \\& b","title":"Example"},{"location":"tutorials/definitions/math/#hamming-distance","text":"Hamming distance is the number of errors in a communication system.","title":"Hamming Distance"},{"location":"tutorials/definitions/math/#example_1","text":"H_d(\\text{12345}, \\text{22345}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{12545}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{22355}) = 2 \\\\[1em] H_d(\\text{12345}, \\text{54321}) = 4 \\\\[1em]","title":"Example"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EDAC Testing and Education Platform This is basically a testing and educatiing platform so that you can - Learn Basic Error Detecting And Correcting - Use the EDAC code - Test your EDAC","title":"EDAC Testing and Education Platform"},{"location":"#edac-testing-and-education-platform","text":"This is basically a testing and educatiing platform so that you can - Learn Basic Error Detecting And Correcting - Use the EDAC code - Test your EDAC","title":"EDAC Testing and Education Platform"},{"location":"sources/","text":"EDAC A Learning Program for Error Decoding and Correction Installations git clone https://github.com/N0Ball/EDAC.git python3 -m pip install -r requirements Docs Documentations make view-docs # Open a server to view documentation make build-docs # Auto create docs from code make deploy-docs # Create doc on github page","title":"EDAC"},{"location":"sources/#edac","text":"A Learning Program for Error Decoding and Correction","title":"EDAC"},{"location":"sources/#installations","text":"git clone https://github.com/N0Ball/EDAC.git python3 -m pip install -r requirements","title":"Installations"},{"location":"sources/#docs","text":"Documentations make view-docs # Open a server to view documentation make build-docs # Auto create docs from code make deploy-docs # Create doc on github page","title":"Docs"},{"location":"sources/modules/edac/factory/","text":"EDACFactory source EDACFactory( edac_type: EDACType, debug: bool = False, **kwargs ) Creates the EDAC System specify by given EDAC Type Args edac_type ( EDACType ) : The EDAC type needed debug (bool) : Debug Level Methods: .encode source .encode( data: bytes, n: int = None ) Encodes the data with edac system Args data (bytes) : The data to be encoded n (int) : The block size given ( None as default) Returns bytes : The data encoded .__get_edac_generator source .__get_edac_generator( edac_type: EDACType ) Get the edac system specified by EDACType Raises ValueError : If no EDAC Type was found Returns EDAC system ._create_block source ._create_block( data: bytes, n: int ) Parse data into blocks so that every block have n bits of data Raises ValueError : If the data's type isn't bytes Returns list : the list of blocks needed .decode source .decode( data: bytes, n: int = None ) Decodes the data to verify the integrity Args data (bytes) : The data to be decode Returns tuple (bool, bytes, list) : should be formated (error, original data, error bits)","title":"Factory"},{"location":"sources/modules/edac/factory/#_1","text":"","title":""},{"location":"sources/modules/edac/factory/#edacfactory","text":"source EDACFactory( edac_type: EDACType, debug: bool = False, **kwargs ) Creates the EDAC System specify by given EDAC Type Args edac_type ( EDACType ) : The EDAC type needed debug (bool) : Debug Level Methods:","title":"EDACFactory"},{"location":"sources/modules/edac/factory/#encode","text":"source .encode( data: bytes, n: int = None ) Encodes the data with edac system Args data (bytes) : The data to be encoded n (int) : The block size given ( None as default) Returns bytes : The data encoded","title":".encode"},{"location":"sources/modules/edac/factory/#__get_edac_generator","text":"source .__get_edac_generator( edac_type: EDACType ) Get the edac system specified by EDACType Raises ValueError : If no EDAC Type was found Returns EDAC system","title":".__get_edac_generator"},{"location":"sources/modules/edac/factory/#_create_block","text":"source ._create_block( data: bytes, n: int ) Parse data into blocks so that every block have n bits of data Raises ValueError : If the data's type isn't bytes Returns list : the list of blocks needed","title":"._create_block"},{"location":"sources/modules/edac/factory/#decode","text":"source .decode( data: bytes, n: int = None ) Decodes the data to verify the integrity Args data (bytes) : The data to be decode Returns tuple (bool, bytes, list) : should be formated (error, original data, error bits)","title":".decode"},{"location":"sources/modules/edac/schema/","text":"EDACType source EDACType() Enumerate of the EDAC Type system EDACMethod source EDACMethod( edac_type: EDACType = EDACType.NO_EDAC, debug: bool = False ) The Base class of the EDAC Method which means that all EDAC should contains all the methods it contains and will only be call the method it contains Args TYPE ( EDACType ) : The type of the EDAC system DEBUG (bool) : Debug flag Methods: .encode source .encode( data: int ) The method that the EDAC system need to encode for futher EDAC usage Args data (int) : the data to be encoded Returns int : the data encoded .get_default_block source .get_default_block() Generate default block of the EDAC system Returns int : default block of the EDAC system .get_parity_size source .get_parity_size() Generate the parity size of the EDAC system Returns int : parity size of the EDAC system .decode source .decode( data: int, check: int ) The method that the EDAC system need to decode for checking the correctness Args data (int) : The data to be checked check (int) : Parity Code to check Returns tuple : format should be (error, data, error bits) error (bool) : Is the data corrupted data (bytes) : The fixed data (return 0x00 if can't be fixed) bits (list) : The index of errorbits","title":"Schema"},{"location":"sources/modules/edac/schema/#_1","text":"","title":""},{"location":"sources/modules/edac/schema/#edactype","text":"source EDACType() Enumerate of the EDAC Type system","title":"EDACType"},{"location":"sources/modules/edac/schema/#edacmethod","text":"source EDACMethod( edac_type: EDACType = EDACType.NO_EDAC, debug: bool = False ) The Base class of the EDAC Method which means that all EDAC should contains all the methods it contains and will only be call the method it contains Args TYPE ( EDACType ) : The type of the EDAC system DEBUG (bool) : Debug flag Methods:","title":"EDACMethod"},{"location":"sources/modules/edac/schema/#encode","text":"source .encode( data: int ) The method that the EDAC system need to encode for futher EDAC usage Args data (int) : the data to be encoded Returns int : the data encoded","title":".encode"},{"location":"sources/modules/edac/schema/#get_default_block","text":"source .get_default_block() Generate default block of the EDAC system Returns int : default block of the EDAC system","title":".get_default_block"},{"location":"sources/modules/edac/schema/#get_parity_size","text":"source .get_parity_size() Generate the parity size of the EDAC system Returns int : parity size of the EDAC system","title":".get_parity_size"},{"location":"sources/modules/edac/schema/#decode","text":"source .decode( data: int, check: int ) The method that the EDAC system need to decode for checking the correctness Args data (int) : The data to be checked check (int) : Parity Code to check Returns tuple : format should be (error, data, error bits) error (bool) : Is the data corrupted data (bytes) : The fixed data (return 0x00 if can't be fixed) bits (list) : The index of errorbits","title":".decode"},{"location":"sources/modules/edac/methods/crc/","text":"CRC source CRC( debug: bool = False, *args, **kwargs ) EDAC System to deal with data that needs CRC Args debug (bool, optional) : Debug level. Defualts to False. kwargs (optional) : The keyword argument passed from EDAC Factory . Defualts to None. should contian key schema schema ( SCHEMA ) : The schema of CRC you chose to use, defaults to CRC_8_ATM Methods: .encode source .encode( data: int ) Encode the given data Args data (int) : the data in integer Returns int : the syndrome in interger ._devide source ._devide( data: int ) Devide in GF( 2^n ) of given generator Args data (int) : the given data Returns int : the result .decode source .decode( data: int, check: int ) Decode the given data Args data (int) : the target data to decode check (int) : syndrome Returns tuple : the results of the decode see more","title":"Crc"},{"location":"sources/modules/edac/methods/crc/#_1","text":"","title":""},{"location":"sources/modules/edac/methods/crc/#crc","text":"source CRC( debug: bool = False, *args, **kwargs ) EDAC System to deal with data that needs CRC Args debug (bool, optional) : Debug level. Defualts to False. kwargs (optional) : The keyword argument passed from EDAC Factory . Defualts to None. should contian key schema schema ( SCHEMA ) : The schema of CRC you chose to use, defaults to CRC_8_ATM Methods:","title":"CRC"},{"location":"sources/modules/edac/methods/crc/#encode","text":"source .encode( data: int ) Encode the given data Args data (int) : the data in integer Returns int : the syndrome in interger","title":".encode"},{"location":"sources/modules/edac/methods/crc/#_devide","text":"source ._devide( data: int ) Devide in GF( 2^n ) of given generator Args data (int) : the given data Returns int : the result","title":"._devide"},{"location":"sources/modules/edac/methods/crc/#decode","text":"source .decode( data: int, check: int ) Decode the given data Args data (int) : the target data to decode check (int) : syndrome Returns tuple : the results of the decode see more","title":".decode"},{"location":"sources/modules/edac/methods/hammingcode/","text":"HammingCode source HammingCode( debug: bool = False ) EDAC System to deal with data that needs hamming code Args debug (bool, optional) : Debug level. Defaults to False. Methods: .encode source .encode( data: int ) Encode the given data Args data (int) : the data in integer Returns int : the encoded data in integer ._create_table source ._create_table( data: int ) Create the hamming table according to the given block size Args data (int) : data Returns list : hamming table .decode source .decode( data: int, check: int ) Decode the given data Args data (int) : the given data check (int) : parity bytes Returns tuple : the results of the decode see more","title":"Hammingcode"},{"location":"sources/modules/edac/methods/hammingcode/#_1","text":"","title":""},{"location":"sources/modules/edac/methods/hammingcode/#hammingcode","text":"source HammingCode( debug: bool = False ) EDAC System to deal with data that needs hamming code Args debug (bool, optional) : Debug level. Defaults to False. Methods:","title":"HammingCode"},{"location":"sources/modules/edac/methods/hammingcode/#encode","text":"source .encode( data: int ) Encode the given data Args data (int) : the data in integer Returns int : the encoded data in integer","title":".encode"},{"location":"sources/modules/edac/methods/hammingcode/#_create_table","text":"source ._create_table( data: int ) Create the hamming table according to the given block size Args data (int) : data Returns list : hamming table","title":"._create_table"},{"location":"sources/modules/edac/methods/hammingcode/#decode","text":"source .decode( data: int, check: int ) Decode the given data Args data (int) : the given data check (int) : parity bytes Returns tuple : the results of the decode see more","title":".decode"},{"location":"sources/modules/edac/methods/parity/","text":"Parity source Parity( debug: bool = False ) A Parity EDAC System to deal with data that needs parity code added Args debug (bool, optional) : Debug Level. Defaults to False. Methods: .encode source .encode( data: int ) encode the given integer (was bytes) Args data (int) : given integer Returns int : integer that is encoded .decode source .decode( data: int, check: int ) Check the if the data is same as the given parity code See Also EDACMethod Args data (int) : given data check (int) : parity bit Returns tuple : ( error , data , error bits ) error (bool) : If any error happens in the data data (int) : the corrected data ( 0 for CI ) bits (list) : the index of the error bits CI for Cannot Identify","title":"Parity"},{"location":"sources/modules/edac/methods/parity/#_1","text":"","title":""},{"location":"sources/modules/edac/methods/parity/#parity","text":"source Parity( debug: bool = False ) A Parity EDAC System to deal with data that needs parity code added Args debug (bool, optional) : Debug Level. Defaults to False. Methods:","title":"Parity"},{"location":"sources/modules/edac/methods/parity/#encode","text":"source .encode( data: int ) encode the given integer (was bytes) Args data (int) : given integer Returns int : integer that is encoded","title":".encode"},{"location":"sources/modules/edac/methods/parity/#decode","text":"source .decode( data: int, check: int ) Check the if the data is same as the given parity code See Also EDACMethod Args data (int) : given data check (int) : parity bit Returns tuple : ( error , data , error bits ) error (bool) : If any error happens in the data data (int) : the corrected data ( 0 for CI ) bits (list) : the index of the error bits CI for Cannot Identify","title":".decode"},{"location":"sources/modules/edac/methods/crc_methods/schema/","text":"SCHEMA source SCHEMA() Schema used for CRC REFERENCED FROM WIKI INCLUDE: Method CRC_1 CRC_5_CCITT CRC_5_USB CRC_7 CRC_8 CRC_8_ATM CRC_8_CCITT CRC_8_DALLAS CRC_8_MAXIM CRC_12 CRC_16_CCITT CRC_16_IBM CRC_16_BBS CRC_32_IEEE CRC_32_C CRC_64_ISO CRC_64_ECMA_182","title":"Schema"},{"location":"sources/modules/edac/methods/crc_methods/schema/#_1","text":"","title":""},{"location":"sources/modules/edac/methods/crc_methods/schema/#schema","text":"source SCHEMA() Schema used for CRC REFERENCED FROM WIKI INCLUDE: Method CRC_1 CRC_5_CCITT CRC_5_USB CRC_7 CRC_8 CRC_8_ATM CRC_8_CCITT CRC_8_DALLAS CRC_8_MAXIM CRC_12 CRC_16_CCITT CRC_16_IBM CRC_16_BBS CRC_32_IEEE CRC_32_C CRC_64_ISO CRC_64_ECMA_182","title":"SCHEMA"},{"location":"sources/modules/noise/factory/","text":"NoiseFactory source NoiseFactory( noise_type: NoiseType, debug: bool = False, **kwargs ) Creates a noise system to add noise to. Args noise_type ( NoiseType ) : The noise type of the given type debug (bool, optional) : The debug flag. Defaults to False. Example >>> noise_system = NoiseFactory(NoiseType.NO_NOISE) >>> noise_system.add_noise(b\"123\") b'123' SeeAlso: NoiseType Methods: .add_noise source .add_noise( data: bytes ) Add noise to the data Args data (bytes) : data to add noise on Raises ValueError : data's type is not bytes Returns bytes : the data with the noise .__get_noise_generator source .__get_noise_generator( noise_type: NoiseType ) Get the noise system of the given noise type Args noise_type ( NoiseType ) : the givin noise type seealso: noise.shceme.NoiseType Raises ValueError : No noise type found Returns NoiseMethod : the noise system","title":"Factory"},{"location":"sources/modules/noise/factory/#_1","text":"","title":""},{"location":"sources/modules/noise/factory/#noisefactory","text":"source NoiseFactory( noise_type: NoiseType, debug: bool = False, **kwargs ) Creates a noise system to add noise to. Args noise_type ( NoiseType ) : The noise type of the given type debug (bool, optional) : The debug flag. Defaults to False. Example >>> noise_system = NoiseFactory(NoiseType.NO_NOISE) >>> noise_system.add_noise(b\"123\") b'123' SeeAlso: NoiseType Methods:","title":"NoiseFactory"},{"location":"sources/modules/noise/factory/#add_noise","text":"source .add_noise( data: bytes ) Add noise to the data Args data (bytes) : data to add noise on Raises ValueError : data's type is not bytes Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/factory/#__get_noise_generator","text":"source .__get_noise_generator( noise_type: NoiseType ) Get the noise system of the given noise type Args noise_type ( NoiseType ) : the givin noise type seealso: noise.shceme.NoiseType Raises ValueError : No noise type found Returns NoiseMethod : the noise system","title":".__get_noise_generator"},{"location":"sources/modules/noise/schema/","text":"NoiseType source NoiseType() The Noise type Enumerate of the Noise system Attributes NO_NOISE (A system with no Noise) : see also NO_NOISE BIT_FLIP (A system that flip bits) : see also BIT_FLIP NoiseMethod source NoiseMethod( noise_type: NoiseType = NoiseType.NO_NOISE, debug: bool = False ) The Base class fo the Noise Method Args TYPE (NoiseType) : The type of noise system DEBUG (bool) : Debug Flag Note This is the abstract base class, add_noise method should never be called Methods: .add_noise source .add_noise( data: bytes ) Add the noise to the data from the noise system Args data (bytes) : the data that the noise is going to add on Returns bytes : the data with the noise","title":"Schema"},{"location":"sources/modules/noise/schema/#_1","text":"","title":""},{"location":"sources/modules/noise/schema/#noisetype","text":"source NoiseType() The Noise type Enumerate of the Noise system Attributes NO_NOISE (A system with no Noise) : see also NO_NOISE BIT_FLIP (A system that flip bits) : see also BIT_FLIP","title":"NoiseType"},{"location":"sources/modules/noise/schema/#noisemethod","text":"source NoiseMethod( noise_type: NoiseType = NoiseType.NO_NOISE, debug: bool = False ) The Base class fo the Noise Method Args TYPE (NoiseType) : The type of noise system DEBUG (bool) : Debug Flag Note This is the abstract base class, add_noise method should never be called Methods:","title":"NoiseMethod"},{"location":"sources/modules/noise/schema/#add_noise","text":"source .add_noise( data: bytes ) Add the noise to the data from the noise system Args data (bytes) : the data that the noise is going to add on Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/systems/BIT_FLIP/","text":"BitFlipNoise source BitFlipNoise( debug: bool, kwargs: dict = None ) Add the Bit Flip Noise System to the data Args debug (bool) : the debug flag kwargs (optional) : The key word argument passed from Noise Factory . Defaults to None. should contain key flip_list flip_list (list[int]) : A list of integer index that defines the bit index that should be flipped Note the **kwargs should be flip_list (list[int]) , if no such key in **kwargs it will auto flips a random bit Example >>> from lib.noise.schema import NoiseType >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP, flip_list=[6]) >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP) >>> noise_system.add_noise(b'OUO') b'OuO' >>> noise_system.add_noise(b'OUO') b'O\u00d5O' Methods: .__add_noise source .__add_noise( data: bytes ) The method to add noise Args data (bytes) : The data to add noise at Returns bytes : the data with the noise Note The algorithm of this method is using a xor mask to flip the data , since x ^ 0 = x, x ^ 1 = !x Given an example | 0 | 1 | 2 | 3 | 4 | | 1 | 0 | 1 | 1 | 0 | --------------------- XOR | 0 | 0 | 1 | 0 | 1 | --------------------- Results | 1 | 0 |*0*| 1 |*1*| You can see that except the 2^{nd} and the 4^{th} data, the data remains the same. .add_noise source .add_noise( data: bytes ) Validate the flip_list and add the noise to the data Args data (bytes) : The data to be noise added Raises IndexError : the flip_list contains integers that exceeds the length of the original data Returns bytes : the data with the noise","title":"BIT FLIP"},{"location":"sources/modules/noise/systems/BIT_FLIP/#_1","text":"","title":""},{"location":"sources/modules/noise/systems/BIT_FLIP/#bitflipnoise","text":"source BitFlipNoise( debug: bool, kwargs: dict = None ) Add the Bit Flip Noise System to the data Args debug (bool) : the debug flag kwargs (optional) : The key word argument passed from Noise Factory . Defaults to None. should contain key flip_list flip_list (list[int]) : A list of integer index that defines the bit index that should be flipped Note the **kwargs should be flip_list (list[int]) , if no such key in **kwargs it will auto flips a random bit Example >>> from lib.noise.schema import NoiseType >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP, flip_list=[6]) >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP) >>> noise_system.add_noise(b'OUO') b'OuO' >>> noise_system.add_noise(b'OUO') b'O\u00d5O' Methods:","title":"BitFlipNoise"},{"location":"sources/modules/noise/systems/BIT_FLIP/#__add_noise","text":"source .__add_noise( data: bytes ) The method to add noise Args data (bytes) : The data to add noise at Returns bytes : the data with the noise Note The algorithm of this method is using a xor mask to flip the data , since x ^ 0 = x, x ^ 1 = !x Given an example | 0 | 1 | 2 | 3 | 4 | | 1 | 0 | 1 | 1 | 0 | --------------------- XOR | 0 | 0 | 1 | 0 | 1 | --------------------- Results | 1 | 0 |*0*| 1 |*1*| You can see that except the 2^{nd} and the 4^{th} data, the data remains the same.","title":".__add_noise"},{"location":"sources/modules/noise/systems/BIT_FLIP/#add_noise","text":"source .add_noise( data: bytes ) Validate the flip_list and add the noise to the data Args data (bytes) : The data to be noise added Raises IndexError : the flip_list contains integers that exceeds the length of the original data Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/systems/NO_NOISE/","text":"NoNoise source NoNoise( debug: bool ) A Noise system without any noise Args debug (bool) : the debug flag Methods: .add_noise source .add_noise( data: bytes ) The Method of adding noise to the data Args data (bytes) : the data that is going to add noise on Returns bytes : the data with noise","title":"NO NOISE"},{"location":"sources/modules/noise/systems/NO_NOISE/#_1","text":"","title":""},{"location":"sources/modules/noise/systems/NO_NOISE/#nonoise","text":"source NoNoise( debug: bool ) A Noise system without any noise Args debug (bool) : the debug flag Methods:","title":"NoNoise"},{"location":"sources/modules/noise/systems/NO_NOISE/#add_noise","text":"source .add_noise( data: bytes ) The Method of adding noise to the data Args data (bytes) : the data that is going to add noise on Returns bytes : the data with noise","title":".add_noise"},{"location":"tutorials/ErrorDetection/hammingCode/","text":"Hamming Code A SEC-DED method. Capable of detect and correct errors. How The index of the data can be seperate into different groups by the index of it's binary data. [1] Therefore, the index of a 2^{n} -bit data can be presented with n groups (n-bits). If we set the significant bit [2] as the parity bit of each group, we can know which groups contain error. If there are only one error bit, the combination of the groups that contains error is the index of the bit that is error. [4] The 0^{th} bit of the data doesn't belongs to any group . This means that we can't use the above method to identify if it is correct or not. However we can set the 0^{th} bit as the parity bit to the whole data string as an identify of 2 errors. Since groups expect that there are only one errors in the data; however if there exists over one errors, the groups will only try to fix one error (which is correcting an correct data -> creates another incorrect data). This means that if only two errors exist, the fix will make 3 errors. Summary For every 2^{n} -bit data, we need (n+1)-bit parity bits (1 the 0^{th} bit). The combinations of the error groups can identify the error ( SEC ). The 0^{th} bit is the parity bit for the whole data ( DED ). Examples take 2^3 bits data, which is a (8-3-1, 4) -> (4, 4) hamming code for example. Encode If the data is 1011 -> the message will be xxx1x011 GROUPS 0: x, 1, 0, 1 -> x = 0 1: x, 1, 1, 1 -> x = 1 2: x, 0, 1, 1 -> x = 0 Therefore the message becomes x0110011 -> x = 0 ( parity bit ). We get the final encoded message 00110011 . Decode Simple git rid of the parity bits: 00110011 -> xxx1x011 -> 1011 Error Detection Example 1 00110011 -> 001100111 (change bit 5 -> the 5^{th} bit have error). GROUPS 0: 0, 1, 1, 1 -> 1 -> INCORRECT 1: 1, 1, 1, 1 -> 0 -> CORRECT 2: 0, 1, 1, 1 -> 1 -> INCORRECT We have detected the error! (1, 0, 1) = 0b101 = 5 [4] . Therefore we can correct it by flipping the 5^{th} bit. 00110111 -> 00110011 , we get the original data. Example 2 00110011 -> 00110001 (change bit 6) GROUPS 0: 0, 1, 0, 1 -> 0 -> CORRECT 1: 1, 1, 0, 1 -> 1 -> INCORRECT 2: 0, 0, 0, 1 -> 1 -> INCORRECT We have detected the error! (1, 1, 0) = 0b110 = 6 [4] . Therefore we can correct it by flipping the 6^{th} bit. 00110001 -> 00110011 , we get the original data. Example 3 00110011 -> 00110101 (change bit 5 and 6) GROUPS 0: 0, 1, 1, 1 -> 1 -> INCORRECT 1: 1, 1, 0, 1 -> 1 -> INCORRECT 2: 0, 1, 0, 1 -> 0 -> CORRECT We think that we detected the error! (0, 1, 1) = 0b011 = 3. Therefore we tried to correct it by flipping the 3^{rd} bit, which makes three incorrects. 00110101 -> 00100101 , we can see that the 0^{th} bit parity didn't pass. We find an error that can't be corrected. More The result of this can be viewed as the sum of the index of the data that have 1 Take Example 1 as an example. 00110011 -> the 2, 3, 6, 7 bit have 1 . 010 011 110 111 + --- 000 -> This is what we set, every group's sum is 0 Therefore if 00110011 -> 00110111 (change bit 5) 010 011 101 110 111 + --- 101 = 5 -> This is the same as what we do above but turned 90 degrees That is, we can simple sum all the index that have 1 . The result of will be the index that have error. Do you see the mathematics inside? We make the sum (which is xor ) of all the indexs that the data contains 1 to 0 -> the encoding. Since 0 ^ x = x -> if there are only one error, we can simply detect the error by sum it again. -> error detecting. Python Code Below are simple python codes for encoding and decoding. Encoding >>> from functools import reduce >>> message = [list(map(int, \"1011\"))] >>> encodeMatrix = [ ... [1, 1, 1, 0, 0, 0, 0], ... [1, 0, 0, 1, 1, 0, 0], ... [0, 1, 0, 1, 0, 1, 0], ... [1, 1, 0, 1, 0, 0, 1] ... ] # the encode procedure can be written as a matrix >>> encode = list(*[[sum(a*b for a,b in zip(X_row,Y_col))%2 for Y_col in zip(*encodeMatrix)] for X_row in message]) # encode the data >>> encode.insert(reduce(lambda a, b: int(a) ^ int(b), encode), 0) # Create 0th bit parity >>> encode [0, 0, 1, 1, 0, 0, 1, 1] Error detecting >>> encode = [0, 0, 1, 1, 0, 0, 1, 1] >>> reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))]) 0 # No errors >>> encode = [0, 0, 1, 0, 0, 0, 1, 1] >>> reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))]) 3 # Third bit have error Error Correcting Correct single error >>> encode = [0, 0, 1, 0, 0, 0, 1, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] >>> encode[reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))])] ^= 1 >>> reduce(lambda a, b: int(a) ^ int(b), encode) == 0 True >>> encode [0, 0, 1, 1, 0, 0, 1, 1] # Successfully fix the error Detects double error >>> encode = [0, 0, 1, 0, 1, 0, 1, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] >>> encode[reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))])] ^= 1 >>> reduce(lambda a, b: int(a) ^ int(b), encode) == 0 False # Unfixable detected (double error) Problem As we know, this is a double error detecting system, therefore, if the hamming distance H(m) \\gt 2 . Though the results might give you correct; however it is incorrect >>> encode = [0, 0, 1, 0, 1, 0, 0, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] >>> encode[reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))])] ^= 1 >>> reduce(lambda a, b: int(a) ^ int(b), encode) == 0 True >>> encode [0, 1, 1, 0, 1, 0, 0, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] -> Different from original We can see that although it says that it successfully corrects the message; however it is still different from its original message. Reference [1] For example: 0 -> 0b000 1 -> 0b001 2 -> 0b010 3 -> 0b011 4 -> 0b100 5 -> 0b101 6 -> 0b110 7 -> 0b111 The 0^{th} group is 0, 2, 4, 7 , since the 0^{th} index of thier binaries are 1 ( 0b001 , 0b011 , 0b101 , 0b111 ). The 1^{st} group is 2, 3, 6, 7 ( 0b010 , 0b011 , 0b110 , 0b111 ). [2] The significant bit of a group is the bit that have only one 1 while presented in binary [3] . The reason we choose this is beacuse significsant bits are one and only to thier groups since they have only one 1 . That is, for group 0 , 1 is the significant bit, and 1 is only in group 0 ; however 3 is not is because group 0 containes 3 , but 3 is in both group 0 and gorup 1 . [3] For example: significant bit of the group 0 is 1 since 1 is 0b00000001 , which only one 1 exists in the binary. The significant bit of group 5 is 32 , since 32 is 0b00100000 , also only one 1 is in it's binary. We can also say that the significant bit of group n is 2n , since that is how binary is. [4] Take a 2^3 -bit data as an example: There are 3 groups O is correct X is incorrect There are only one error. (Single Error) GROUPS 0: 1, 3, 5, 7 1: 2, 3, 6, 7 2: 4, 5, 6, 7 COMBINATIONS | 2 | 1 | 0 | error bit | |---+---+---+-----------| | O | O | O | X | |---+---+---+-----------| | O | O | X | 1 | |---+---+---+-----------| | O | X | O | 2 | |---+---+---+-----------| | O | X | X | 3 | |---+---+---+-----------| | X | O | O | 4 | |---+---+---+-----------| | X | O | X | 5 | |---+---+---+-----------| | X | X | O | 6 | |---+---+---+-----------| | X | X | X | 7 | |-----------------------| If only group 1 is incorrect -> Second bit have error ( 2 ). group 0 and group 2 is correct. since we are finding the incorrect bit the number can't be in group 0 and group 2 (since both of the groups are correct). the number must be in group 1 (since the group is incorrect). you can't find any number except 2 that contains group 1 but group 0 and group 2 . If both group 0 and group 1 is incorrect -> Third bit have error ( 3 ). only group 2 is correct. since we are finding the incorrect bit the number can't be in group 2 (since group 2 is correct). the number must be in group 0 and group 1 (since both of the groups are incorrect). you can't find any number except 3 that contains group 0 and group 1 but group 2 . If both group 1 and group 2 is incorrect -> Sixth bit have error ( 6 ). only group 0 is correct. since we are finding the incorrect bit the number can't be in group 0 (since group 0 is correct). the number must be in group 1 and group 2 (since both of the groups are incorrect). you can't find any number except 6 that contains group 1 and group 2 but group 0 . Do you see the relation of error groups and indexs? If we see the incorrect groups as 1 , the correct groups as 0 , we can view the combination of groups as one binary number, the error is the result of the binary. That is (remember, the index should be inverse, since 0b001 the zeroth index is the right most): If only group 1 is incorrect. (0, 1, 0) -> 0b010 -> 2 second bit have error. If both group 0 and group 1 is incorrect. (0, 1, 1) -> 0b011 -> 3 third bit have error. If both group 1 and group 2 is incorrect. (1, 1, 0) -> 0b110 -> 6 sixth bit have error. We get the same result as above.","title":"hammingCode"},{"location":"tutorials/ErrorDetection/hammingCode/#_1","text":"","title":""},{"location":"tutorials/ErrorDetection/hammingCode/#hamming-code","text":"A SEC-DED method. Capable of detect and correct errors.","title":"Hamming Code"},{"location":"tutorials/ErrorDetection/hammingCode/#how","text":"The index of the data can be seperate into different groups by the index of it's binary data. [1] Therefore, the index of a 2^{n} -bit data can be presented with n groups (n-bits). If we set the significant bit [2] as the parity bit of each group, we can know which groups contain error. If there are only one error bit, the combination of the groups that contains error is the index of the bit that is error. [4] The 0^{th} bit of the data doesn't belongs to any group . This means that we can't use the above method to identify if it is correct or not. However we can set the 0^{th} bit as the parity bit to the whole data string as an identify of 2 errors. Since groups expect that there are only one errors in the data; however if there exists over one errors, the groups will only try to fix one error (which is correcting an correct data -> creates another incorrect data). This means that if only two errors exist, the fix will make 3 errors.","title":"How"},{"location":"tutorials/ErrorDetection/hammingCode/#summary","text":"For every 2^{n} -bit data, we need (n+1)-bit parity bits (1 the 0^{th} bit). The combinations of the error groups can identify the error ( SEC ). The 0^{th} bit is the parity bit for the whole data ( DED ).","title":"Summary"},{"location":"tutorials/ErrorDetection/hammingCode/#examples","text":"take 2^3 bits data, which is a (8-3-1, 4) -> (4, 4) hamming code for example.","title":"Examples"},{"location":"tutorials/ErrorDetection/hammingCode/#encode","text":"If the data is 1011 -> the message will be xxx1x011 GROUPS 0: x, 1, 0, 1 -> x = 0 1: x, 1, 1, 1 -> x = 1 2: x, 0, 1, 1 -> x = 0 Therefore the message becomes x0110011 -> x = 0 ( parity bit ). We get the final encoded message 00110011 .","title":"Encode"},{"location":"tutorials/ErrorDetection/hammingCode/#decode","text":"Simple git rid of the parity bits: 00110011 -> xxx1x011 -> 1011","title":"Decode"},{"location":"tutorials/ErrorDetection/hammingCode/#error-detection","text":"","title":"Error Detection"},{"location":"tutorials/ErrorDetection/hammingCode/#example-1","text":"00110011 -> 001100111 (change bit 5 -> the 5^{th} bit have error). GROUPS 0: 0, 1, 1, 1 -> 1 -> INCORRECT 1: 1, 1, 1, 1 -> 0 -> CORRECT 2: 0, 1, 1, 1 -> 1 -> INCORRECT We have detected the error! (1, 0, 1) = 0b101 = 5 [4] . Therefore we can correct it by flipping the 5^{th} bit. 00110111 -> 00110011 , we get the original data.","title":"Example 1"},{"location":"tutorials/ErrorDetection/hammingCode/#example-2","text":"00110011 -> 00110001 (change bit 6) GROUPS 0: 0, 1, 0, 1 -> 0 -> CORRECT 1: 1, 1, 0, 1 -> 1 -> INCORRECT 2: 0, 0, 0, 1 -> 1 -> INCORRECT We have detected the error! (1, 1, 0) = 0b110 = 6 [4] . Therefore we can correct it by flipping the 6^{th} bit. 00110001 -> 00110011 , we get the original data.","title":"Example 2"},{"location":"tutorials/ErrorDetection/hammingCode/#example-3","text":"00110011 -> 00110101 (change bit 5 and 6) GROUPS 0: 0, 1, 1, 1 -> 1 -> INCORRECT 1: 1, 1, 0, 1 -> 1 -> INCORRECT 2: 0, 1, 0, 1 -> 0 -> CORRECT We think that we detected the error! (0, 1, 1) = 0b011 = 3. Therefore we tried to correct it by flipping the 3^{rd} bit, which makes three incorrects. 00110101 -> 00100101 , we can see that the 0^{th} bit parity didn't pass. We find an error that can't be corrected.","title":"Example 3"},{"location":"tutorials/ErrorDetection/hammingCode/#more","text":"The result of this can be viewed as the sum of the index of the data that have 1 Take Example 1 as an example. 00110011 -> the 2, 3, 6, 7 bit have 1 . 010 011 110 111 + --- 000 -> This is what we set, every group's sum is 0 Therefore if 00110011 -> 00110111 (change bit 5) 010 011 101 110 111 + --- 101 = 5 -> This is the same as what we do above but turned 90 degrees That is, we can simple sum all the index that have 1 . The result of will be the index that have error. Do you see the mathematics inside? We make the sum (which is xor ) of all the indexs that the data contains 1 to 0 -> the encoding. Since 0 ^ x = x -> if there are only one error, we can simply detect the error by sum it again. -> error detecting.","title":"More"},{"location":"tutorials/ErrorDetection/hammingCode/#python-code","text":"Below are simple python codes for encoding and decoding.","title":"Python Code"},{"location":"tutorials/ErrorDetection/hammingCode/#encoding","text":">>> from functools import reduce >>> message = [list(map(int, \"1011\"))] >>> encodeMatrix = [ ... [1, 1, 1, 0, 0, 0, 0], ... [1, 0, 0, 1, 1, 0, 0], ... [0, 1, 0, 1, 0, 1, 0], ... [1, 1, 0, 1, 0, 0, 1] ... ] # the encode procedure can be written as a matrix >>> encode = list(*[[sum(a*b for a,b in zip(X_row,Y_col))%2 for Y_col in zip(*encodeMatrix)] for X_row in message]) # encode the data >>> encode.insert(reduce(lambda a, b: int(a) ^ int(b), encode), 0) # Create 0th bit parity >>> encode [0, 0, 1, 1, 0, 0, 1, 1]","title":"Encoding"},{"location":"tutorials/ErrorDetection/hammingCode/#error-detecting","text":">>> encode = [0, 0, 1, 1, 0, 0, 1, 1] >>> reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))]) 0 # No errors >>> encode = [0, 0, 1, 0, 0, 0, 1, 1] >>> reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))]) 3 # Third bit have error","title":"Error detecting"},{"location":"tutorials/ErrorDetection/hammingCode/#error-correcting","text":"Correct single error >>> encode = [0, 0, 1, 0, 0, 0, 1, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] >>> encode[reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))])] ^= 1 >>> reduce(lambda a, b: int(a) ^ int(b), encode) == 0 True >>> encode [0, 0, 1, 1, 0, 0, 1, 1] # Successfully fix the error Detects double error >>> encode = [0, 0, 1, 0, 1, 0, 1, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] >>> encode[reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))])] ^= 1 >>> reduce(lambda a, b: int(a) ^ int(b), encode) == 0 False # Unfixable detected (double error)","title":"Error Correcting"},{"location":"tutorials/ErrorDetection/hammingCode/#problem","text":"As we know, this is a double error detecting system, therefore, if the hamming distance H(m) \\gt 2 . Though the results might give you correct; however it is incorrect >>> encode = [0, 0, 1, 0, 1, 0, 0, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] >>> encode[reduce(lambda a, b: a^b, [e[0] for e in filter(lambda x: x[1], enumerate(encode))])] ^= 1 >>> reduce(lambda a, b: int(a) ^ int(b), encode) == 0 True >>> encode [0, 1, 1, 0, 1, 0, 0, 1] # Original [0, 0, 1, 1, 0, 0, 1, 1] -> Different from original We can see that although it says that it successfully corrects the message; however it is still different from its original message.","title":"Problem"},{"location":"tutorials/ErrorDetection/hammingCode/#reference","text":"","title":"Reference"},{"location":"tutorials/ErrorDetection/hammingCode/#1","text":"For example: 0 -> 0b000 1 -> 0b001 2 -> 0b010 3 -> 0b011 4 -> 0b100 5 -> 0b101 6 -> 0b110 7 -> 0b111 The 0^{th} group is 0, 2, 4, 7 , since the 0^{th} index of thier binaries are 1 ( 0b001 , 0b011 , 0b101 , 0b111 ). The 1^{st} group is 2, 3, 6, 7 ( 0b010 , 0b011 , 0b110 , 0b111 ).","title":"[1]"},{"location":"tutorials/ErrorDetection/hammingCode/#2","text":"The significant bit of a group is the bit that have only one 1 while presented in binary [3] . The reason we choose this is beacuse significsant bits are one and only to thier groups since they have only one 1 . That is, for group 0 , 1 is the significant bit, and 1 is only in group 0 ; however 3 is not is because group 0 containes 3 , but 3 is in both group 0 and gorup 1 .","title":"[2]"},{"location":"tutorials/ErrorDetection/hammingCode/#3","text":"For example: significant bit of the group 0 is 1 since 1 is 0b00000001 , which only one 1 exists in the binary. The significant bit of group 5 is 32 , since 32 is 0b00100000 , also only one 1 is in it's binary. We can also say that the significant bit of group n is 2n , since that is how binary is.","title":"[3]"},{"location":"tutorials/ErrorDetection/hammingCode/#4","text":"Take a 2^3 -bit data as an example: There are 3 groups O is correct X is incorrect There are only one error. (Single Error) GROUPS 0: 1, 3, 5, 7 1: 2, 3, 6, 7 2: 4, 5, 6, 7 COMBINATIONS | 2 | 1 | 0 | error bit | |---+---+---+-----------| | O | O | O | X | |---+---+---+-----------| | O | O | X | 1 | |---+---+---+-----------| | O | X | O | 2 | |---+---+---+-----------| | O | X | X | 3 | |---+---+---+-----------| | X | O | O | 4 | |---+---+---+-----------| | X | O | X | 5 | |---+---+---+-----------| | X | X | O | 6 | |---+---+---+-----------| | X | X | X | 7 | |-----------------------| If only group 1 is incorrect -> Second bit have error ( 2 ). group 0 and group 2 is correct. since we are finding the incorrect bit the number can't be in group 0 and group 2 (since both of the groups are correct). the number must be in group 1 (since the group is incorrect). you can't find any number except 2 that contains group 1 but group 0 and group 2 . If both group 0 and group 1 is incorrect -> Third bit have error ( 3 ). only group 2 is correct. since we are finding the incorrect bit the number can't be in group 2 (since group 2 is correct). the number must be in group 0 and group 1 (since both of the groups are incorrect). you can't find any number except 3 that contains group 0 and group 1 but group 2 . If both group 1 and group 2 is incorrect -> Sixth bit have error ( 6 ). only group 0 is correct. since we are finding the incorrect bit the number can't be in group 0 (since group 0 is correct). the number must be in group 1 and group 2 (since both of the groups are incorrect). you can't find any number except 6 that contains group 1 and group 2 but group 0 . Do you see the relation of error groups and indexs? If we see the incorrect groups as 1 , the correct groups as 0 , we can view the combination of groups as one binary number, the error is the result of the binary. That is (remember, the index should be inverse, since 0b001 the zeroth index is the right most): If only group 1 is incorrect. (0, 1, 0) -> 0b010 -> 2 second bit have error. If both group 0 and group 1 is incorrect. (0, 1, 1) -> 0b011 -> 3 third bit have error. If both group 1 and group 2 is incorrect. (1, 1, 0) -> 0b110 -> 6 sixth bit have error. We get the same result as above.","title":"[4]"},{"location":"tutorials/ErrorDetection/parity/","text":"Parity bit Check Bit , which is a bit that can detect errors. How Examing the Least significant bit of the whole communication string Applied in an 8-bit communication system 7 + 1(parity) the sum of every bit should be 0 Examples take 25 (0b11001) as an example 0 1 2 3 4 5 6 7 0 0 1 1 0 0 1 1 The parity bit is the 7 th bit, since the sum of every bit in 25 (0b11001) is 1 ; therefore the value of parity bit is 0 - 1 = 0 \\oplus 1 = 1 take 30 (0b11110) as an example 0 1 2 3 4 5 6 7 0 0 1 1 1 1 0 0 The parity bit is the 7 th bit, since the sum of every bit in 30 (0b11110) is 0 ; therefore the value of parity bit is 0 - 0 = 0 \\oplus 0 = 0 Error Detection If single bit flip occurs, the sum of the bits will not be 0. That is, you can simply sum every bits to check whether an error appears. a simple python code to check 30 (0b11110) is listed below >>> from functools import reduce >>> message = \"00111100\" # e = 0b0 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True >>> message = \"00110100\" # e = 0b1000 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 False Problems The bigest problem of parity bit is that you can't identify the error if the hamming distance H_d(m) is odd. Check m = 30 (0b11110) again but with H_d(m) = 2 with error e 11000000 => m + e = (0b1111110) >>> from functools import reduce >>> message = \"11111100\" # Message recieved in Binary >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True The result is True which means no errors however, e \\ne 0 This is called a collision , which means two different system have the same parity code See also Numbers Summations Hamming Distance","title":"Parity"},{"location":"tutorials/ErrorDetection/parity/#_1","text":"","title":""},{"location":"tutorials/ErrorDetection/parity/#parity-bit","text":"Check Bit , which is a bit that can detect errors.","title":"Parity bit"},{"location":"tutorials/ErrorDetection/parity/#how","text":"Examing the Least significant bit of the whole communication string Applied in an 8-bit communication system 7 + 1(parity) the sum of every bit should be 0","title":"How"},{"location":"tutorials/ErrorDetection/parity/#examples","text":"take 25 (0b11001) as an example 0 1 2 3 4 5 6 7 0 0 1 1 0 0 1 1 The parity bit is the 7 th bit, since the sum of every bit in 25 (0b11001) is 1 ; therefore the value of parity bit is 0 - 1 = 0 \\oplus 1 = 1 take 30 (0b11110) as an example 0 1 2 3 4 5 6 7 0 0 1 1 1 1 0 0 The parity bit is the 7 th bit, since the sum of every bit in 30 (0b11110) is 0 ; therefore the value of parity bit is 0 - 0 = 0 \\oplus 0 = 0","title":"Examples"},{"location":"tutorials/ErrorDetection/parity/#error-detection","text":"If single bit flip occurs, the sum of the bits will not be 0. That is, you can simply sum every bits to check whether an error appears. a simple python code to check 30 (0b11110) is listed below >>> from functools import reduce >>> message = \"00111100\" # e = 0b0 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True >>> message = \"00110100\" # e = 0b1000 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 False","title":"Error Detection"},{"location":"tutorials/ErrorDetection/parity/#problems","text":"The bigest problem of parity bit is that you can't identify the error if the hamming distance H_d(m) is odd. Check m = 30 (0b11110) again but with H_d(m) = 2 with error e 11000000 => m + e = (0b1111110) >>> from functools import reduce >>> message = \"11111100\" # Message recieved in Binary >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True The result is True which means no errors however, e \\ne 0 This is called a collision , which means two different system have the same parity code","title":"Problems"},{"location":"tutorials/ErrorDetection/parity/#see-also","text":"Numbers Summations Hamming Distance","title":"See also"},{"location":"tutorials/definitions/EDAC/","text":"Intro This is definitions of Error Detection And Correction related page. SEC-DED Single Error Correction Double Error Detection (SEC-DED) Description EDAC schemes that are capable of detecting up to two simultaneous bit errors and correcting single-bit errors. Examples Hamming Code Huffman Coding Hsia SEC-DED","title":"EDAC"},{"location":"tutorials/definitions/EDAC/#_1","text":"","title":""},{"location":"tutorials/definitions/EDAC/#intro","text":"This is definitions of Error Detection And Correction related page.","title":"Intro"},{"location":"tutorials/definitions/EDAC/#sec-ded","text":"Single Error Correction Double Error Detection (SEC-DED)","title":"SEC-DED"},{"location":"tutorials/definitions/EDAC/#description","text":"EDAC schemes that are capable of detecting up to two simultaneous bit errors and correcting single-bit errors.","title":"Description"},{"location":"tutorials/definitions/EDAC/#examples","text":"Hamming Code Huffman Coding Hsia SEC-DED","title":"Examples"},{"location":"tutorials/definitions/computerScience/","text":"Intro This is definitions of Computer Science related page Numbers The numbers in CS can be Binary \\rightarrow 0, 1 Octal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7 Decimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Hexadecimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, a, b, c, d, e, f Example take 25 as example >>> number = 25 >>> number #Decimal 25 >>> bin(number) #Binary '0b11001' >>> oct(number) #Octal '0o31' >>> hex(number) #Hexadecimal '0x19' The notation of this tutorial will always be: Binary -> 0b Octal -> 0o Decimal -> NA (No Notation) Hexadecimal -> 0x That is 0b11001 = 0o31 = 0x19 = 25 Least Significant Bit (LSB) the 1^{st} bit of the data, which is also the low-order bit or right-most bit Example >>> def LSB(n): ... return n&1 >>> number = 15 >>> bin(number) '0b1111' >>> LSB(number) 1 >>> number = 14 >>> bin(number) '0b1110' >>> LSB(number) 0 Most Significant Bit (MSB) The high-order bit or left-most bit Example Given a 8 bit system >>> def MSB(n): ... return n >> 7 ... >>> number = 215 >>> bin(number) '0b11010111' >>> MSB(number) 1 >>> number = 127 >>> bin(number) '0b1111111' #It's actuall 0b01111111 since it's a 8-bit system >>> MSB(number) 0","title":"computerScience"},{"location":"tutorials/definitions/computerScience/#_1","text":"","title":""},{"location":"tutorials/definitions/computerScience/#intro","text":"This is definitions of Computer Science related page","title":"Intro"},{"location":"tutorials/definitions/computerScience/#numbers","text":"The numbers in CS can be Binary \\rightarrow 0, 1 Octal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7 Decimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Hexadecimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, a, b, c, d, e, f","title":"Numbers"},{"location":"tutorials/definitions/computerScience/#example","text":"take 25 as example >>> number = 25 >>> number #Decimal 25 >>> bin(number) #Binary '0b11001' >>> oct(number) #Octal '0o31' >>> hex(number) #Hexadecimal '0x19' The notation of this tutorial will always be: Binary -> 0b Octal -> 0o Decimal -> NA (No Notation) Hexadecimal -> 0x That is 0b11001 = 0o31 = 0x19 = 25","title":"Example"},{"location":"tutorials/definitions/computerScience/#least-significant-bit-lsb","text":"the 1^{st} bit of the data, which is also the low-order bit or right-most bit","title":"Least Significant Bit (LSB)"},{"location":"tutorials/definitions/computerScience/#example_1","text":">>> def LSB(n): ... return n&1 >>> number = 15 >>> bin(number) '0b1111' >>> LSB(number) 1 >>> number = 14 >>> bin(number) '0b1110' >>> LSB(number) 0","title":"Example"},{"location":"tutorials/definitions/computerScience/#most-significant-bit-msb","text":"The high-order bit or left-most bit","title":"Most Significant Bit (MSB)"},{"location":"tutorials/definitions/computerScience/#example_2","text":"Given a 8 bit system >>> def MSB(n): ... return n >> 7 ... >>> number = 215 >>> bin(number) '0b11010111' >>> MSB(number) 1 >>> number = 127 >>> bin(number) '0b1111111' #It's actuall 0b01111111 since it's a 8-bit system >>> MSB(number) 0","title":"Example"},{"location":"tutorials/definitions/math/","text":"Intro This is definitions of mathematic related page Summations In Communication systems, the summation of bits or strings is in a Galios Field (GF) Example take GF(2) for example A B Operation Result 0 0 +/- 0 0 1 +/- 1 1 0 +/- 1 1 1 +/- 0 0 0 x 0 0 1 x 0 1 0 x 0 1 1 x 1 As you can see, the +/- in GF(2) is also xor operation and x is and operation. That is a \\pm b = a \\oplus b \\\\[1em] a \\times b = a \\& b Hamming Distance Hamming distance is the number of errors in a communication system. Example H_d(\\text{12345}, \\text{22345}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{12545}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{22355}) = 2 \\\\[1em] H_d(\\text{12345}, \\text{54321}) = 4 \\\\[1em]","title":"Math"},{"location":"tutorials/definitions/math/#_1","text":"","title":""},{"location":"tutorials/definitions/math/#intro","text":"This is definitions of mathematic related page","title":"Intro"},{"location":"tutorials/definitions/math/#summations","text":"In Communication systems, the summation of bits or strings is in a Galios Field (GF)","title":"Summations"},{"location":"tutorials/definitions/math/#example","text":"take GF(2) for example A B Operation Result 0 0 +/- 0 0 1 +/- 1 1 0 +/- 1 1 1 +/- 0 0 0 x 0 0 1 x 0 1 0 x 0 1 1 x 1 As you can see, the +/- in GF(2) is also xor operation and x is and operation. That is a \\pm b = a \\oplus b \\\\[1em] a \\times b = a \\& b","title":"Example"},{"location":"tutorials/definitions/math/#hamming-distance","text":"Hamming distance is the number of errors in a communication system.","title":"Hamming Distance"},{"location":"tutorials/definitions/math/#example_1","text":"H_d(\\text{12345}, \\text{22345}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{12545}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{22355}) = 2 \\\\[1em] H_d(\\text{12345}, \\text{54321}) = 4 \\\\[1em]","title":"Example"}]}
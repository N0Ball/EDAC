{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EDAC Testing and Education Platform This is basically a testing and educatiing platform so that you can - Learn Basic Error Detecting And Correcting - Use the EDAC code - Test your EDAC","title":"EDAC Testing and Education Platform"},{"location":"#edac-testing-and-education-platform","text":"This is basically a testing and educatiing platform so that you can - Learn Basic Error Detecting And Correcting - Use the EDAC code - Test your EDAC","title":"EDAC Testing and Education Platform"},{"location":"sources/","text":"EDAC A Learning Program for Error Decoding and Correction Installations git clone https://github.com/N0Ball/EDAC.git python3 -m pip install -r requirements Docs Documentations make view-docs # Open a server to view documentation make build-docs # Auto create docs from code make deploy-docs # Create doc on github page","title":"EDAC"},{"location":"sources/#edac","text":"A Learning Program for Error Decoding and Correction","title":"EDAC"},{"location":"sources/#installations","text":"git clone https://github.com/N0Ball/EDAC.git python3 -m pip install -r requirements","title":"Installations"},{"location":"sources/#docs","text":"Documentations make view-docs # Open a server to view documentation make build-docs # Auto create docs from code make deploy-docs # Create doc on github page","title":"Docs"},{"location":"sources/modules/edac/factory/","text":"EDACFactory source EDACFactory( edac_type: EDACType, debug: bool = False ) Creates the EDAC System specify by given EDAC Type Args edac_type ( EDACType ) : The EDAC type needed debug (bool) : Debug Level Methods: .decode source .decode( data: bytes, n: int = None ) Decodes the data to verify the integrity Args data (bytes) : The data to be decode Returns tuple (bool, bytes, list) : should be formated (error, original data, error bits) ._create_block source ._create_block( data: bytes, n: int ) Parse data into blocks so that every block have n bits of data Raises ValueError : If the data's type isn't bytes Returns list : the list of blocks needed .encode source .encode( data: bytes, n: int = None ) Encodes the data with edac system Args data (bytes) : The data to be encoded n (int) : The block size given ( None as default) Returns bytes : The data encoded .__get_edac_generator source .__get_edac_generator( edac_type: EDACType ) Get the edac system specified by EDACType Raises ValueError : If no EDAC Type was found Returns EDAC system","title":"Factory"},{"location":"sources/modules/edac/factory/#_1","text":"","title":""},{"location":"sources/modules/edac/factory/#edacfactory","text":"source EDACFactory( edac_type: EDACType, debug: bool = False ) Creates the EDAC System specify by given EDAC Type Args edac_type ( EDACType ) : The EDAC type needed debug (bool) : Debug Level Methods:","title":"EDACFactory"},{"location":"sources/modules/edac/factory/#decode","text":"source .decode( data: bytes, n: int = None ) Decodes the data to verify the integrity Args data (bytes) : The data to be decode Returns tuple (bool, bytes, list) : should be formated (error, original data, error bits)","title":".decode"},{"location":"sources/modules/edac/factory/#_create_block","text":"source ._create_block( data: bytes, n: int ) Parse data into blocks so that every block have n bits of data Raises ValueError : If the data's type isn't bytes Returns list : the list of blocks needed","title":"._create_block"},{"location":"sources/modules/edac/factory/#encode","text":"source .encode( data: bytes, n: int = None ) Encodes the data with edac system Args data (bytes) : The data to be encoded n (int) : The block size given ( None as default) Returns bytes : The data encoded","title":".encode"},{"location":"sources/modules/edac/factory/#__get_edac_generator","text":"source .__get_edac_generator( edac_type: EDACType ) Get the edac system specified by EDACType Raises ValueError : If no EDAC Type was found Returns EDAC system","title":".__get_edac_generator"},{"location":"sources/modules/edac/schema/","text":"EDACType source EDACType() Enumerate of the EDAC Type system EDACMethod source EDACMethod( edac_type: EDACType = EDACType.NO_EDAC, debug: bool = False ) The Base class of the EDAC Method which means that all EDAC should contains all the methods it contains and will only be call the method it contains Args TYPE ( EDACType ) : The type of the EDAC system DEBUG (bool) : Debug flag Methods: .get_default_block source .get_default_block() Generate default block of the EDAC system Returns int : default block of the EDAC system .decode source .decode( data: int, check: int ) The method that the EDAC system need to decode for checking the correctness Args data (int) : The data to be checked check (int) : Parity Code to check Returns tuple : format should be (error, data, error bits) error (bool) : Is the data corrupted data (bytes) : The fixed data (return 0x00 if can't be fixed) bits (list) : The index of errorbits .get_parity_size source .get_parity_size() Generate the parity size of the EDAC system Returns int : parity size of the EDAC system .encode source .encode( data: int ) The method that the EDAC system need to encode for futher EDAC usage Args data (int) : the data to be encoded Returns int : the data encoded","title":"Schema"},{"location":"sources/modules/edac/schema/#_1","text":"","title":""},{"location":"sources/modules/edac/schema/#edactype","text":"source EDACType() Enumerate of the EDAC Type system","title":"EDACType"},{"location":"sources/modules/edac/schema/#edacmethod","text":"source EDACMethod( edac_type: EDACType = EDACType.NO_EDAC, debug: bool = False ) The Base class of the EDAC Method which means that all EDAC should contains all the methods it contains and will only be call the method it contains Args TYPE ( EDACType ) : The type of the EDAC system DEBUG (bool) : Debug flag Methods:","title":"EDACMethod"},{"location":"sources/modules/edac/schema/#get_default_block","text":"source .get_default_block() Generate default block of the EDAC system Returns int : default block of the EDAC system","title":".get_default_block"},{"location":"sources/modules/edac/schema/#decode","text":"source .decode( data: int, check: int ) The method that the EDAC system need to decode for checking the correctness Args data (int) : The data to be checked check (int) : Parity Code to check Returns tuple : format should be (error, data, error bits) error (bool) : Is the data corrupted data (bytes) : The fixed data (return 0x00 if can't be fixed) bits (list) : The index of errorbits","title":".decode"},{"location":"sources/modules/edac/schema/#get_parity_size","text":"source .get_parity_size() Generate the parity size of the EDAC system Returns int : parity size of the EDAC system","title":".get_parity_size"},{"location":"sources/modules/edac/schema/#encode","text":"source .encode( data: int ) The method that the EDAC system need to encode for futher EDAC usage Args data (int) : the data to be encoded Returns int : the data encoded","title":".encode"},{"location":"sources/modules/edac/methods/parity/","text":"Parity source Parity( debug: bool = False ) A Parity EDAC System to deal with data that needs parity code added Args debug (bool, optional) : Debug Level. Defaults to False. Methods: .decode source .decode( data: int, check: int ) Check the if the data is same as the given parity code See Also EDACMethod Args data (int) : given data check (int) : parity bit Returns tuple : ( error , data , error bits ) error (bool) : If any error happens in the data data (int) : the corrected data ( 0 for CI ) bits (list) : the index of the error bits CI for Cannot Identify .encode source .encode( data: int ) encode the given integer (was bytes) Args data (int) : given integer Returns int : integer that is encoded","title":"Parity"},{"location":"sources/modules/edac/methods/parity/#_1","text":"","title":""},{"location":"sources/modules/edac/methods/parity/#parity","text":"source Parity( debug: bool = False ) A Parity EDAC System to deal with data that needs parity code added Args debug (bool, optional) : Debug Level. Defaults to False. Methods:","title":"Parity"},{"location":"sources/modules/edac/methods/parity/#decode","text":"source .decode( data: int, check: int ) Check the if the data is same as the given parity code See Also EDACMethod Args data (int) : given data check (int) : parity bit Returns tuple : ( error , data , error bits ) error (bool) : If any error happens in the data data (int) : the corrected data ( 0 for CI ) bits (list) : the index of the error bits CI for Cannot Identify","title":".decode"},{"location":"sources/modules/edac/methods/parity/#encode","text":"source .encode( data: int ) encode the given integer (was bytes) Args data (int) : given integer Returns int : integer that is encoded","title":".encode"},{"location":"sources/modules/noise/factory/","text":"NoiseFactory source NoiseFactory( noise_type: NoiseType, debug: bool = False, **kwargs ) Creates a noise system to add noise to. Args noise_type ( NoiseType ) : The noise type of the given type debug (bool, optional) : The debug flag. Defaults to False. Example >>> noise_system = NoiseFactory(NoiseType.NO_NOISE) >>> noise_system.add_noise(b\"123\") b'123' SeeAlso: NoiseType Methods: .add_noise source .add_noise( data: bytes ) Add noise to the data Args data (bytes) : data to add noise on Raises ValueError : data's type is not bytes Returns bytes : the data with the noise .__get_noise_generator source .__get_noise_generator( noise_type: NoiseType ) Get the noise system of the given noise type Args noise_type ( NoiseType ) : the givin noise type seealso: noise.shceme.NoiseType Raises ValueError : No noise type found Returns NoiseMethod : the noise system","title":"Factory"},{"location":"sources/modules/noise/factory/#_1","text":"","title":""},{"location":"sources/modules/noise/factory/#noisefactory","text":"source NoiseFactory( noise_type: NoiseType, debug: bool = False, **kwargs ) Creates a noise system to add noise to. Args noise_type ( NoiseType ) : The noise type of the given type debug (bool, optional) : The debug flag. Defaults to False. Example >>> noise_system = NoiseFactory(NoiseType.NO_NOISE) >>> noise_system.add_noise(b\"123\") b'123' SeeAlso: NoiseType Methods:","title":"NoiseFactory"},{"location":"sources/modules/noise/factory/#add_noise","text":"source .add_noise( data: bytes ) Add noise to the data Args data (bytes) : data to add noise on Raises ValueError : data's type is not bytes Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/factory/#__get_noise_generator","text":"source .__get_noise_generator( noise_type: NoiseType ) Get the noise system of the given noise type Args noise_type ( NoiseType ) : the givin noise type seealso: noise.shceme.NoiseType Raises ValueError : No noise type found Returns NoiseMethod : the noise system","title":".__get_noise_generator"},{"location":"sources/modules/noise/schema/","text":"NoiseType source NoiseType() The Noise type Enumerate of the Noise system Attributes NO_NOISE (A system with no Noise) : see also NO_NOISE BIT_FLIP (A system that flip bits) : see also BIT_FLIP NoiseMethod source NoiseMethod( noise_type: NoiseType = NoiseType.NO_NOISE, debug: bool = False ) The Base class fo the Noise Method Args TYPE (NoiseType) : The type of noise system DEBUG (bool) : Debug Flag Note This is the abstract base class, add_noise method should never be called Methods: .add_noise source .add_noise( data: bytes ) Add the noise to the data from the noise system Args data (bytes) : the data that the noise is going to add on Returns bytes : the data with the noise","title":"Schema"},{"location":"sources/modules/noise/schema/#_1","text":"","title":""},{"location":"sources/modules/noise/schema/#noisetype","text":"source NoiseType() The Noise type Enumerate of the Noise system Attributes NO_NOISE (A system with no Noise) : see also NO_NOISE BIT_FLIP (A system that flip bits) : see also BIT_FLIP","title":"NoiseType"},{"location":"sources/modules/noise/schema/#noisemethod","text":"source NoiseMethod( noise_type: NoiseType = NoiseType.NO_NOISE, debug: bool = False ) The Base class fo the Noise Method Args TYPE (NoiseType) : The type of noise system DEBUG (bool) : Debug Flag Note This is the abstract base class, add_noise method should never be called Methods:","title":"NoiseMethod"},{"location":"sources/modules/noise/schema/#add_noise","text":"source .add_noise( data: bytes ) Add the noise to the data from the noise system Args data (bytes) : the data that the noise is going to add on Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/systems/BIT_FLIP/","text":"BitFlipNoise source BitFlipNoise( debug: bool, kwargs: dict = None ) Add the Bit Flip Noise System to the data Args debug (bool) : the debug flag kwargs (optional) : The key word argument passed from Noise Factory . Defaults to None. should contain key flip_list flip_list (list[int]) : A list of integer index that defines the bit index that should be flipped Note the **kwargs should be flip_list (list[int]) , if no such key in **kwargs it will auto flips a random bit Example >>> from lib.noise.schema import NoiseType >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP, flip_list=[6]) >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP) >>> noise_system.add_noise(b'OUO') b'OuO' >>> noise_system.add_noise(b'OUO') b'O\u00d5O' Methods: .__add_noise source .__add_noise( data: bytes ) The method to add noise Args data (bytes) : The data to add noise at Returns bytes : the data with the noise Note The algorithm of this method is using a xor mask to flip the data , since x ^ 0 = x, x ^ 1 = !x Given an example | 0 | 1 | 2 | 3 | 4 | | 1 | 0 | 1 | 1 | 0 | --------------------- XOR | 0 | 0 | 1 | 0 | 1 | --------------------- Results | 1 | 0 |*0*| 1 |*1*| You can see that except the 2^{nd} and the 4^{th} data, the data remains the same. .add_noise source .add_noise( data: bytes ) Validate the flip_list and add the noise to the data Args data (bytes) : The data to be noise added Raises IndexError : the flip_list contains integers that exceeds the length of the original data Returns bytes : the data with the noise","title":"BIT FLIP"},{"location":"sources/modules/noise/systems/BIT_FLIP/#_1","text":"","title":""},{"location":"sources/modules/noise/systems/BIT_FLIP/#bitflipnoise","text":"source BitFlipNoise( debug: bool, kwargs: dict = None ) Add the Bit Flip Noise System to the data Args debug (bool) : the debug flag kwargs (optional) : The key word argument passed from Noise Factory . Defaults to None. should contain key flip_list flip_list (list[int]) : A list of integer index that defines the bit index that should be flipped Note the **kwargs should be flip_list (list[int]) , if no such key in **kwargs it will auto flips a random bit Example >>> from lib.noise.schema import NoiseType >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP, flip_list=[6]) >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system.add_noise(b'OUO') b'MUO' >>> noise_system = NoiseFactory(NoiseType.BIT_FLIP) >>> noise_system.add_noise(b'OUO') b'OuO' >>> noise_system.add_noise(b'OUO') b'O\u00d5O' Methods:","title":"BitFlipNoise"},{"location":"sources/modules/noise/systems/BIT_FLIP/#__add_noise","text":"source .__add_noise( data: bytes ) The method to add noise Args data (bytes) : The data to add noise at Returns bytes : the data with the noise Note The algorithm of this method is using a xor mask to flip the data , since x ^ 0 = x, x ^ 1 = !x Given an example | 0 | 1 | 2 | 3 | 4 | | 1 | 0 | 1 | 1 | 0 | --------------------- XOR | 0 | 0 | 1 | 0 | 1 | --------------------- Results | 1 | 0 |*0*| 1 |*1*| You can see that except the 2^{nd} and the 4^{th} data, the data remains the same.","title":".__add_noise"},{"location":"sources/modules/noise/systems/BIT_FLIP/#add_noise","text":"source .add_noise( data: bytes ) Validate the flip_list and add the noise to the data Args data (bytes) : The data to be noise added Raises IndexError : the flip_list contains integers that exceeds the length of the original data Returns bytes : the data with the noise","title":".add_noise"},{"location":"sources/modules/noise/systems/NO_NOISE/","text":"NoNoise source NoNoise( debug: bool ) A Noise system without any noise Args debug (bool) : the debug flag Methods: .add_noise source .add_noise( data: bytes ) The Method of adding noise to the data Args data (bytes) : the data that is going to add noise on Returns bytes : the data with noise","title":"NO NOISE"},{"location":"sources/modules/noise/systems/NO_NOISE/#_1","text":"","title":""},{"location":"sources/modules/noise/systems/NO_NOISE/#nonoise","text":"source NoNoise( debug: bool ) A Noise system without any noise Args debug (bool) : the debug flag Methods:","title":"NoNoise"},{"location":"sources/modules/noise/systems/NO_NOISE/#add_noise","text":"source .add_noise( data: bytes ) The Method of adding noise to the data Args data (bytes) : the data that is going to add noise on Returns bytes : the data with noise","title":".add_noise"},{"location":"tutorials/ErrorDetection/parity/","text":"Parity bit Check Bit , which is a bit that can detect errors. How Examing the Least significant bit of the whole communication string Applied in an 8-bit communication system 7 + 1(parity) the sum of every bit should be 0 Examples take 25 (0b11001) as an example 0 1 2 3 4 5 6 7 0 0 1 1 0 0 1 1 The parity bit is the 7 th bit, since the sum of every bit in 25 (0b11001) is 1 ; therefore the value of parity bit is 0 - 1 = 0 \\oplus 1 = 1 take 30 (0b11110) as an example 0 1 2 3 4 5 6 7 0 0 1 1 1 1 0 0 The parity bit is the 7 th bit, since the sum of every bit in 30 (0b11110) is 0 ; therefore the value of parity bit is 0 - 0 = 0 \\oplus 0 = 0 Error Detection If single bit flip occurs, the sum of the bits will not be 0. That is, you can simply sum every bits to check whether an error appears. a simple python code to check 30 (0b11110) is listed below >>> from functools import reduce >>> message = \"00111100\" # e = 0b0 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True >>> message = \"00110100\" # e = 0b1000 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 False Problems The bigest problem of parity bit is that you can't identify the error if the hamming distance H_d(m) \\gt 1 Check m = 30 (0b11110) again but with H_d(m) = 2 with error e 11000000 => m + e = (0b1111110) >>> from functools import reduce >>> message = \"11111100\" # Message recieved in Binary >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True The result is True which means no errors however, e \\ne 0 This is called a collision , which means two different system have the same parity code See also Numbers Summations Hamming Distance","title":"Parity"},{"location":"tutorials/ErrorDetection/parity/#_1","text":"","title":""},{"location":"tutorials/ErrorDetection/parity/#parity-bit","text":"Check Bit , which is a bit that can detect errors.","title":"Parity bit"},{"location":"tutorials/ErrorDetection/parity/#how","text":"Examing the Least significant bit of the whole communication string Applied in an 8-bit communication system 7 + 1(parity) the sum of every bit should be 0","title":"How"},{"location":"tutorials/ErrorDetection/parity/#examples","text":"take 25 (0b11001) as an example 0 1 2 3 4 5 6 7 0 0 1 1 0 0 1 1 The parity bit is the 7 th bit, since the sum of every bit in 25 (0b11001) is 1 ; therefore the value of parity bit is 0 - 1 = 0 \\oplus 1 = 1 take 30 (0b11110) as an example 0 1 2 3 4 5 6 7 0 0 1 1 1 1 0 0 The parity bit is the 7 th bit, since the sum of every bit in 30 (0b11110) is 0 ; therefore the value of parity bit is 0 - 0 = 0 \\oplus 0 = 0","title":"Examples"},{"location":"tutorials/ErrorDetection/parity/#error-detection","text":"If single bit flip occurs, the sum of the bits will not be 0. That is, you can simply sum every bits to check whether an error appears. a simple python code to check 30 (0b11110) is listed below >>> from functools import reduce >>> message = \"00111100\" # e = 0b0 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True >>> message = \"00110100\" # e = 0b1000 >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 False","title":"Error Detection"},{"location":"tutorials/ErrorDetection/parity/#problems","text":"The bigest problem of parity bit is that you can't identify the error if the hamming distance H_d(m) \\gt 1 Check m = 30 (0b11110) again but with H_d(m) = 2 with error e 11000000 => m + e = (0b1111110) >>> from functools import reduce >>> message = \"11111100\" # Message recieved in Binary >>> reduce(lambda a, b: int(a) ^ int(b), message) == 0 True The result is True which means no errors however, e \\ne 0 This is called a collision , which means two different system have the same parity code","title":"Problems"},{"location":"tutorials/ErrorDetection/parity/#see-also","text":"Numbers Summations Hamming Distance","title":"See also"},{"location":"tutorials/definitions/computerScience/","text":"Intro This is definitions of Computer Science related page Numbers The numbers in CS can be Binary \\rightarrow 0, 1 Octal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7 Decimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Hexadecimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, a, b, c, d, e, f Example take 25 as example >>> number = 25 >>> number #Decimal 25 >>> bin(number) #Binary '0b11001' >>> oct(number) #Octal '0o31' >>> hex(number) #Hexadecimal '0x19' The notation of this tutorial will always be: Binary -> 0b Octal -> 0o Decimal -> NA (No Notation) Hexadecimal -> 0x That is 0b11001 = 0o31 = 0x19 = 25 Least Significant Bit (LSB) the 1^{st} bit of the data, which is also the low-order bit or right-most bit Example >>> def LSB(n): ... return n&1 >>> number = 15 >>> bin(number) '0b1111' >>> LSB(number) 1 >>> number = 14 >>> bin(number) '0b1110' >>> LSB(number) 0 Most Significant Bit (MSB) The high-order bit or left-most bit Example Given a 8 bit system >>> def MSB(n): ... return n >> 7 ... >>> number = 215 >>> bin(number) '0b11010111' >>> MSB(number) 1 >>> number = 127 >>> bin(number) '0b1111111' #It's actuall 0b01111111 since it's a 8-bit system >>> MSB(number) 0","title":"computerScience"},{"location":"tutorials/definitions/computerScience/#_1","text":"","title":""},{"location":"tutorials/definitions/computerScience/#intro","text":"This is definitions of Computer Science related page","title":"Intro"},{"location":"tutorials/definitions/computerScience/#numbers","text":"The numbers in CS can be Binary \\rightarrow 0, 1 Octal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7 Decimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Hexadecimal \\rightarrow 0, 1, 2, 3, 4, 5, 6, 7, 8, a, b, c, d, e, f","title":"Numbers"},{"location":"tutorials/definitions/computerScience/#example","text":"take 25 as example >>> number = 25 >>> number #Decimal 25 >>> bin(number) #Binary '0b11001' >>> oct(number) #Octal '0o31' >>> hex(number) #Hexadecimal '0x19' The notation of this tutorial will always be: Binary -> 0b Octal -> 0o Decimal -> NA (No Notation) Hexadecimal -> 0x That is 0b11001 = 0o31 = 0x19 = 25","title":"Example"},{"location":"tutorials/definitions/computerScience/#least-significant-bit-lsb","text":"the 1^{st} bit of the data, which is also the low-order bit or right-most bit","title":"Least Significant Bit (LSB)"},{"location":"tutorials/definitions/computerScience/#example_1","text":">>> def LSB(n): ... return n&1 >>> number = 15 >>> bin(number) '0b1111' >>> LSB(number) 1 >>> number = 14 >>> bin(number) '0b1110' >>> LSB(number) 0","title":"Example"},{"location":"tutorials/definitions/computerScience/#most-significant-bit-msb","text":"The high-order bit or left-most bit","title":"Most Significant Bit (MSB)"},{"location":"tutorials/definitions/computerScience/#example_2","text":"Given a 8 bit system >>> def MSB(n): ... return n >> 7 ... >>> number = 215 >>> bin(number) '0b11010111' >>> MSB(number) 1 >>> number = 127 >>> bin(number) '0b1111111' #It's actuall 0b01111111 since it's a 8-bit system >>> MSB(number) 0","title":"Example"},{"location":"tutorials/definitions/math/","text":"Intro This is definitions of mathematic related page Summations In Communication systems, the summation of bits or strings is in a Galios Field (GF) Example take GF(2) for example A B Operation Result 0 0 +/- 0 0 1 +/- 1 1 0 +/- 1 1 1 +/- 0 0 0 x 0 0 1 x 0 1 0 x 0 1 1 x 1 As you can see, the +/- in GF(2) is also xor operation and x is and operation. That is a \\pm b = a \\oplus b \\\\[1em] a \\times b = a \\& b Hamming Distance Hamming distance is the number of errors in a communication system. Example H_d(\\text{12345}, \\text{22345}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{12545}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{22355}) = 2 \\\\[1em] H_d(\\text{12345}, \\text{54321}) = 4 \\\\[1em]","title":"Math"},{"location":"tutorials/definitions/math/#_1","text":"","title":""},{"location":"tutorials/definitions/math/#intro","text":"This is definitions of mathematic related page","title":"Intro"},{"location":"tutorials/definitions/math/#summations","text":"In Communication systems, the summation of bits or strings is in a Galios Field (GF)","title":"Summations"},{"location":"tutorials/definitions/math/#example","text":"take GF(2) for example A B Operation Result 0 0 +/- 0 0 1 +/- 1 1 0 +/- 1 1 1 +/- 0 0 0 x 0 0 1 x 0 1 0 x 0 1 1 x 1 As you can see, the +/- in GF(2) is also xor operation and x is and operation. That is a \\pm b = a \\oplus b \\\\[1em] a \\times b = a \\& b","title":"Example"},{"location":"tutorials/definitions/math/#hamming-distance","text":"Hamming distance is the number of errors in a communication system.","title":"Hamming Distance"},{"location":"tutorials/definitions/math/#example_1","text":"H_d(\\text{12345}, \\text{22345}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{12545}) = 1 \\\\[1em] H_d(\\text{12345}, \\text{22355}) = 2 \\\\[1em] H_d(\\text{12345}, \\text{54321}) = 4 \\\\[1em]","title":"Example"}]}